{
  ShaderManager.getInstance().enableShader("chunk");
  GL13.glActiveTexture(GL13.GL_TEXTURE1);
  TextureManager.getInstance().bindTexture("custom_lava_still");
  GL13.glActiveTexture(GL13.GL_TEXTURE2);
  TextureManager.getInstance().bindTexture("custom_water_still");
  GL13.glActiveTexture(GL13.GL_TEXTURE0);
  TextureManager.getInstance().bindTexture("terrain");
  int daylight=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"),"daylight");
  int swimming=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"),"swimming");
  int lavaTexture=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"),"textureLava");
  int waterTexture=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"),"textureWater");
  int textureAtlas=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"),"textureAtlas");
  GL20.glUniform1i(lavaTexture,1);
  GL20.glUniform1i(waterTexture,2);
  GL20.glUniform1i(textureAtlas,0);
  int tick=GL20.glGetUniformLocation(ShaderManager.getInstance().getShader("chunk"),"tick");
  boolean playerIsSwimming=_player.isHeadUnderWater();
  GL20.glUniform1f(tick,_tick);
  GL20.glUniform1f(daylight,getDaylight());
  GL20.glUniform1i(swimming,playerIsSwimming ? 1 : 0);
  int occlusionDistanceOffset=(int)(_visibleChunks.size() * OCCLUSION_CULLING_DISTANCE_OFFSET);
  _statOcclusionCulled=0;
  _statSubMeshCulled=0;
  _statEmpty=0;
  _statVisibleTriangles=0;
  for (int i=0; i < _visibleChunks.size(); i++) {
    Chunk c=_visibleChunks.get(i);
    if (OCCLUSION_CULLING_ENABLED) {
      ShaderManager.getInstance().enableShader(null);
      if (!_occlusionQueryToggle) {
        c.applyOcclusionQueries();
      }
 else       if (i > occlusionDistanceOffset) {
        c.executeOcclusionQuery();
      }
 else {
        c.resetOcclusionCulled();
      }
      ShaderManager.getInstance().enableShader("chunk");
    }
    GL11.glPushMatrix();
    GL11.glTranslatef(c.getPosition().x * Chunk.CHUNK_DIMENSION_X - _worldProvider.getRenderingReferencePoint().x,c.getPosition().y * Chunk.CHUNK_DIMENSION_Y - _worldProvider.getRenderingReferencePoint().y,c.getPosition().z * Chunk.CHUNK_DIMENSION_Z - _worldProvider.getRenderingReferencePoint().z);
    for (int j=0; j < Chunk.VERTICAL_SEGMENTS; j++) {
      if (!c.isSubMeshOcclusionCulled(j)) {
        if (isAABBVisible(c.getSubMeshAABB(j))) {
          boolean rendered=c.render(ChunkMesh.RENDER_TYPE.OPAQUE,j);
          _statEmpty+=rendered ? 0 : 1;
          if (rendered) {
            c.setSubMeshCulled(j,false);
          }
 else {
            c.setSubMeshCulled(j,true);
          }
        }
 else {
          c.setSubMeshCulled(j,true);
          _statSubMeshCulled++;
        }
      }
 else {
        _statOcclusionCulled++;
      }
    }
    glPopMatrix();
    if (BOUNDING_BOXES_ENABLED) {
      ShaderManager.getInstance().enableShader(null);
      c.renderAABBs(false);
      ShaderManager.getInstance().enableShader("chunk");
    }
  }
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  for (int i=0; i < _visibleChunks.size(); i++) {
    Chunk c=_visibleChunks.get(i);
    GL11.glPushMatrix();
    GL11.glTranslatef(c.getPosition().x * Chunk.CHUNK_DIMENSION_X - _worldProvider.getRenderingReferencePoint().x,c.getPosition().y * Chunk.CHUNK_DIMENSION_Y - _worldProvider.getRenderingReferencePoint().y,c.getPosition().z * Chunk.CHUNK_DIMENSION_Z - _worldProvider.getRenderingReferencePoint().z);
    for (int k=0; k < Chunk.VERTICAL_SEGMENTS; k++) {
      if (!c.isSubMeshOcclusionCulled(k)) {
        if (!c.isSubMeshCulled(k)) {
          c.render(ChunkMesh.RENDER_TYPE.BILLBOARD_AND_TRANSLUCENT,k);
        }
      }
    }
    glPopMatrix();
  }
  glDisable(GL11.GL_BLEND);
  _mobManager.renderAll();
  ShaderManager.getInstance().enableShader("chunk");
  TextureManager.getInstance().bindTexture("terrain");
  if (playerIsSwimming) {
    glDisable(GL11.GL_CULL_FACE);
  }
  for (int j=0; j < 2; j++) {
    if (j == 0) {
      glColorMask(false,false,false,false);
    }
 else {
      glEnable(GL_BLEND);
      glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
      glColorMask(true,true,true,true);
    }
    for (int i=0; i < _visibleChunks.size(); i++) {
      Chunk c=_visibleChunks.get(i);
      GL11.glPushMatrix();
      GL11.glTranslatef(c.getPosition().x * Chunk.CHUNK_DIMENSION_X - _worldProvider.getRenderingReferencePoint().x,c.getPosition().y * Chunk.CHUNK_DIMENSION_Y - _worldProvider.getRenderingReferencePoint().y,c.getPosition().z * Chunk.CHUNK_DIMENSION_Z - _worldProvider.getRenderingReferencePoint().z);
      for (int k=0; k < Chunk.VERTICAL_SEGMENTS; k++) {
        if (!c.isSubMeshOcclusionCulled(k)) {
          if (!c.isSubMeshCulled(k)) {
            c.render(ChunkMesh.RENDER_TYPE.WATER_AND_ICE,k);
          }
        }
      }
      glPopMatrix();
    }
    glDisable(GL_BLEND);
  }
  glEnable(GL11.GL_CULL_FACE);
  ShaderManager.getInstance().enableShader("block");
  _bulletPhysicsRenderer.render();
  ShaderManager.getInstance().enableShader(null);
  long now=Blockmania.getInstance().getTime();
  if (now - _occlusionLastUpdate > OCCLUSION_CULLING_GAP) {
    _occlusionQueryToggle=!_occlusionQueryToggle;
    _occlusionLastUpdate=now;
  }
}
