{
  for (  CacheRegion cacheRegion : regions) {
    cacheRegion.update();
    if (cacheRegion.isDirty()) {
      cacheRegion.setUpToDate();
      checkForMissingChunks(cacheRegion);
    }
  }
  while (generatePhase.isResultAvailable()) {
    Vector3i chunkPos=generatePhase.poll();
    logger.log(Level.FINE,"Received generated chunk " + chunkPos);
    for (    Vector3i pos : Region3i.createFromCenterExtents(chunkPos,new Vector3i(1,0,1))) {
      checkReadyForSecondPass(pos);
    }
  }
  while (secondPassPhase.isResultAvailable()) {
    Vector3i chunkPos=secondPassPhase.poll();
    logger.log(Level.FINE,"Received second passed chunk " + chunkPos);
    for (    Vector3i pos : Region3i.createFromCenterExtents(chunkPos,new Vector3i(1,0,1))) {
      checkReadyToDoInternalLighting(pos);
    }
  }
  while (internalLightingPhase.isResultAvailable()) {
    Vector3i chunkPos=internalLightingPhase.poll();
    logger.log(Level.FINE,"Received internally lit chunk " + chunkPos);
    for (    Vector3i pos : Region3i.createFromCenterExtents(chunkPos,new Vector3i(1,0,1))) {
      checkReadyToPropagateLighting(pos);
    }
  }
  while (propagateLightPhase.isResultAvailable()) {
    Vector3i chunkPos=propagateLightPhase.poll();
    logger.log(Level.FINE,"Received second passed chunk " + chunkPos);
    for (    Vector3i pos : Region3i.createFromCenterExtents(chunkPos,new Vector3i(1,0,1))) {
      checkComplete(pos);
    }
  }
  if (nearCache.size() > CACHE_SIZE) {
    logger.log(Level.INFO,"Compacting cache");
    Iterator<Vector3i> iterator=nearCache.keySet().iterator();
    while (iterator.hasNext()) {
      Vector3i pos=iterator.next();
      boolean keep=false;
      for (      CacheRegion region : regions) {
        if (region.getRegion().encompasses(pos)) {
          keep=true;
          break;
        }
      }
      if (!keep) {
        NewChunk chunk=nearCache.get(pos);
        farCache.put(chunk);
        iterator.remove();
        chunk.dispose();
      }
    }
  }
}
