{
  mods.clear();
  Gson gson=new Gson();
  for (  Path rootModPath : PathManager.getInstance().getModPaths()) {
    try {
      for (      Path modPath : Files.newDirectoryStream(rootModPath,FilesUtil.DIRECTORY_FILTER)) {
        Path modInfoFile=modPath.resolve("module.txt");
        if (Files.isRegularFile(modInfoFile)) {
          try (Reader reader=Files.newBufferedReader(modInfoFile,TerasologyConstants.CHARSET)){
            ModuleInfo moduleInfo=gson.fromJson(reader,ModuleInfo.class);
            if (!mods.containsKey(moduleInfo.getId().toLowerCase(Locale.ENGLISH))) {
              Path assetLocation=modPath.resolve(ASSETS_SUBDIRECTORY);
              Path overridesLocation=modPath.resolve(OVERRIDES_SUBDIRECTORY);
              AssetSource source=new DirectorySource(moduleInfo.getId(),assetLocation,overridesLocation);
              Module module=new Module(modPath,moduleInfo,source);
              mods.put(moduleInfo.getId().toLowerCase(Locale.ENGLISH),module);
              logger.info("Discovered module: {} (hasCode = {})",moduleInfo.getDisplayName(),module.isCodeMod());
            }
 else {
              logger.info("Discovered duplicate module: {}, skipping",moduleInfo.getDisplayName());
            }
          }
 catch (          FileNotFoundException e) {
            logger.warn("Failed to load module manifest for module at {}",modPath,e);
          }
catch (          JsonIOException e) {
            logger.warn("Failed to load module manifest for module at {}",modPath,e);
          }
        }
      }
    }
 catch (    IOException e) {
      logger.error("Failed to scan for directory mods",e);
    }
    try {
      for (      Path modPath : Files.newDirectoryStream(rootModPath,new DirectoryStream.Filter<Path>(){
        @Override public boolean accept(        Path entry) throws IOException {
          return Files.isRegularFile(entry) && (entry.toString().endsWith(".jar") || entry.toString().endsWith(".zip"));
        }
      }
)) {
        try (ZipFile zipFile=new ZipFile(modPath.toFile())){
          ZipEntry modInfoEntry=zipFile.getEntry("module.txt");
          if (modInfoEntry != null) {
            try {
              ModuleInfo moduleInfo=gson.fromJson(new InputStreamReader(zipFile.getInputStream(modInfoEntry)),ModuleInfo.class);
              if (!mods.containsKey(moduleInfo.getId().toLowerCase(Locale.ENGLISH))) {
                Module module=new Module(modPath,moduleInfo,new ArchiveSource(moduleInfo.getId(),modPath.toFile(),ASSETS_SUBDIRECTORY,OVERRIDES_SUBDIRECTORY));
                mods.put(moduleInfo.getId().toLowerCase(Locale.ENGLISH),module);
                logger.info("Discovered module: {} (hasCode = {})",moduleInfo.getDisplayName(),module.isCodeMod());
              }
 else {
                logger.info("Discovered duplicate module: " + moduleInfo.getDisplayName() + ", skipping");
              }
            }
 catch (            FileNotFoundException e) {
              logger.warn("Failed to load module manifest for module at {}",modPath,e);
            }
catch (            JsonIOException e) {
              logger.warn("Failed to load module manifest for module at {}",modPath,e);
            }
          }
        }
 catch (        IOException e) {
          logger.error("Invalid module file: {}",modPath,e);
        }
      }
    }
 catch (    IOException e) {
      logger.error("Failed to scan for jar and zip mods",e);
    }
  }
  List<URL> urls=Lists.newArrayList();
  for (  Module module : getMods()) {
    if (module.isCodeMod()) {
      urls.add(module.getModClasspathUrl());
    }
  }
  if (allModClassLoader != null) {
    try {
      allModClassLoader.close();
    }
 catch (    IOException e) {
      logger.error("Failed to cloase allModClassLoader",e);
    }
  }
  allModClassLoader=new URLClassLoader(urls.toArray(new URL[urls.size()]),getClass().getClassLoader());
  for (  Module module : getMods()) {
    module.setInactiveClassLoader(allModClassLoader);
  }
  if (activeModClassLoader != null) {
    try {
      activeModClassLoader.close();
    }
 catch (    IOException e) {
      logger.error("Failed to close activeModClassLoader",e);
    }
  }
  allReflections=null;
}
