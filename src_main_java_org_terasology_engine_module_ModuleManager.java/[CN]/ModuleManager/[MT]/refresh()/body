{
  mods.clear();
  Gson gson=new Gson();
  for (  Path rootModPath : PathManager.getInstance().getModPaths()) {
    try {
      for (      Path modPath : Files.newDirectoryStream(rootModPath,FilesUtil.DIRECTORY_FILTER)) {
        processModDirectory(modPath,gson);
      }
    }
 catch (    IOException e) {
      logger.error("Failed to scan for directory mods",e);
    }
    try {
      for (      Path modPath : Files.newDirectoryStream(rootModPath,new DirectoryStream.Filter<Path>(){
        @Override public boolean accept(        Path entry) throws IOException {
          return Files.isRegularFile(entry) && (entry.toString().endsWith(".jar") || entry.toString().endsWith(".zip"));
        }
      }
)) {
        processModArchive(modPath,gson);
      }
    }
 catch (    IOException e) {
      logger.error("Failed to scan for jar and zip mods",e);
    }
  }
  List<URL> urls=Lists.newArrayList();
  for (  Module module : getMods()) {
    if (module.isCodeMod()) {
      urls.add(module.getModClasspathUrl());
    }
  }
  if (allModClassLoader != null) {
    try {
      allModClassLoader.close();
    }
 catch (    IOException e) {
      logger.error("Failed to cloase allModClassLoader",e);
    }
  }
  allModClassLoader=new URLClassLoader(urls.toArray(new URL[urls.size()]),getClass().getClassLoader());
  for (  Module module : getMods()) {
    module.setInactiveClassLoader(allModClassLoader);
  }
  if (activeModClassLoader != null) {
    try {
      activeModClassLoader.close();
    }
 catch (    IOException e) {
      logger.error("Failed to close activeModClassLoader",e);
    }
  }
  allReflections=null;
}
