{
  Class handlerClass=handler.getClass();
  if (!Modifier.isPublic(handlerClass.getModifiers())) {
    logger.warning(String.format("Cannot register handler %s, must be public",handler.getClass().getName()));
    return;
  }
  logger.info("Registering event handler " + handlerClass.getName());
  for (  Method method : handlerClass.getMethods()) {
    ReceiveEvent receiveEventAnnotation=method.getAnnotation(ReceiveEvent.class);
    if (receiveEventAnnotation != null) {
      if (!Modifier.isPublic(method.getModifiers())) {
        method.setAccessible(true);
      }
      Class<?>[] types=method.getParameterTypes();
      if (types.length == 2 && Event.class.isAssignableFrom(types[0]) && EntityRef.class.isAssignableFrom(types[1])) {
        logger.info("Found method: " + method.toString());
        EventHandlerInfo handlerInfo=new EventHandlerInfo(handler,method,receiveEventAnnotation.components(),receiveEventAnnotation.priority());
        for (        Class<? extends Component> c : receiveEventAnnotation.components()) {
          Multimap<Class<? extends Component>,EventHandlerInfo> componentMap=componentSpecificHandlers.get((Class<? extends Event>)types[0]);
          if (componentMap == null) {
            componentMap=HashMultimap.create();
            componentSpecificHandlers.put((Class<? extends Event>)types[0],componentMap);
          }
          componentMap.put(c,handlerInfo);
        }
      }
 else {
        logger.warning("Invalid event handler method: " + method.getName());
      }
    }
  }
}
