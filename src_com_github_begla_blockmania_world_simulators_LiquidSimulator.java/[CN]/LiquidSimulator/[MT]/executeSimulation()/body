{
  if (_activeBlocks.isEmpty())   return;
  BlockPosition bp=_activeBlocks.iterator().next();
  _activeBlocks.remove(bp);
  byte state=_parent.getState(bp.x,bp.y,bp.z);
  byte type=_parent.getBlock(bp.x,bp.y,bp.z);
  byte typeAbove=_parent.getBlock(bp.x,bp.y + 1,bp.z);
  byte typeBelow=_parent.getBlock(bp.x,bp.y - 1,bp.z);
  if (type == typeAbove) {
    state=1;
  }
 else   if (state > 1) {
    int minState=Integer.MAX_VALUE;
    for (int j=0; j < 6; j++) {
      byte nType=_parent.getBlock((int)NEIGHBORS6[j].x * j + bp.x,(int)NEIGHBORS6[j].y * j + bp.y,(int)NEIGHBORS6[j].z * j + bp.z);
      byte nState=_parent.getState((int)NEIGHBORS6[j].x * j + bp.x,(int)NEIGHBORS6[j].y * j + bp.y,(int)NEIGHBORS6[j].z * j + bp.z);
      if (nType == type) {
        if (nState < minState)         minState=nState;
      }
    }
    if (minState + 1 > state) {
      state--;
    }
 else     if (minState + 1 < state)     state++;
  }
  _parent.setState(bp.x,bp.y,bp.z,state);
  if (state > 7) {
    type=0x0;
    _parent.setBlock(bp.x,bp.y,bp.z,type,true,true);
    return;
  }
  if (typeBelow == 0x0) {
    _parent.setBlock(bp.x,bp.y - 1,bp.z,type,true,true);
    _parent.setState(bp.x,bp.y - 1,bp.z,(byte)(state + 1));
    return;
  }
  boolean[] invalid=new boolean[4];
  for (int j=1; j < 5; j++) {
    boolean set=false;
    for (int k=0; k < 4; k++) {
      BlockPosition nBp=new BlockPosition((int)NEIGHBORS4[k].x * j + bp.x,bp.y,(int)NEIGHBORS4[k].z * j + bp.z);
      if (_parent.getBlock(nBp.x,nBp.y,nBp.z) != 0) {
        invalid[k]=true;
      }
 else       if (!invalid[k]) {
        _parent.setBlock(nBp.x,nBp.y,nBp.z,type,true,true);
        _parent.setState(nBp.x,nBp.y,nBp.z,(byte)(state + 1));
        addActiveBlock(nBp);
        set=true;
      }
    }
    if (set)     return;
  }
}
