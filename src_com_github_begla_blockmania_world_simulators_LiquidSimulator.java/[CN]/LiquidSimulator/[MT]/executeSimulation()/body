{
  for (int i=_activeBlocks.size() - 1; i >= 0; i--) {
    BlockPosition bp=_activeBlocks.get(i);
    byte state=_parent.getState(bp.x,bp.y,bp.z);
    byte type=_parent.getBlock(bp.x,bp.y,bp.z);
    byte stateAbove=_parent.getState(bp.x,bp.y + 1,bp.z);
    byte typeAbove=_parent.getBlock(bp.x,bp.y + 1,bp.z);
    byte stateBelow=_parent.getState(bp.x,bp.y - 1,bp.z);
    byte typeBelow=_parent.getBlock(bp.x,bp.y - 1,bp.z);
    if (type == typeAbove) {
      state=1;
    }
 else     if (state > 1) {
      int minState=Integer.MAX_VALUE;
      for (int j=0; j < 6; j++) {
        byte nType=_parent.getBlock((int)NEIGHBORS6[j].x * j + bp.x,(int)NEIGHBORS6[j].y * j + bp.y,(int)NEIGHBORS6[j].z * j + bp.z);
        byte nState=_parent.getState((int)NEIGHBORS6[j].x * j + bp.x,(int)NEIGHBORS6[j].y * j + bp.y,(int)NEIGHBORS6[j].z * j + bp.z);
        if (nType == type) {
          if (nState < minState)           minState=nState;
        }
      }
      if (minState + 1 > state) {
        state--;
      }
 else       if (minState + 1 < state)       state++;
    }
    _parent.setState(bp.x,bp.y,bp.z,state);
    if (state > 7) {
      type=0x0;
      _parent.setBlock(bp.x,bp.y,bp.z,type,true,true,true);
      return;
    }
    if (typeBelow == 0x0) {
      _parent.setBlock(bp.x,bp.y - 1,bp.z,type,true,true,true);
      _parent.setState(bp.x,bp.y - 1,bp.z,(byte)(state + 1));
      break;
    }
    boolean[] invalid=new boolean[4];
    for (int j=1; j < 5; j++) {
      boolean set=false;
      for (int k=0; k < 4; k++) {
        if (_parent.getBlock((int)NEIGHBORS4[k].x * j + bp.x,bp.y,(int)NEIGHBORS4[k].z * j + bp.z) != 0) {
          invalid[k]=true;
        }
 else         if (!invalid[k]) {
          _parent.setBlock((int)NEIGHBORS4[k].x * j + bp.x,bp.y,(int)NEIGHBORS4[k].z * j + bp.z,type,true,true,true);
          _parent.setState((int)NEIGHBORS4[k].x * j + bp.x,bp.y,(int)NEIGHBORS4[k].z * j + bp.z,(byte)(state + 1));
          set=true;
        }
      }
      if (set)       return;
    }
  }
}
