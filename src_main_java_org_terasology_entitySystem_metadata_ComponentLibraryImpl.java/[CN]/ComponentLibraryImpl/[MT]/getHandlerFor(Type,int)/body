{
  Class typeClass;
  if (type instanceof Class) {
    typeClass=(Class)type;
  }
 else   if (type instanceof ParameterizedType) {
    typeClass=(Class)((ParameterizedType)type).getRawType();
  }
 else {
    logger.error("Cannot obtain class for type {}",type);
    return null;
  }
  if (Enum.class.isAssignableFrom(typeClass)) {
    return new EnumTypeHandler(typeClass);
  }
 else   if (List.class.isAssignableFrom(typeClass)) {
    Type parameter=getTypeParameter(type,0);
    if (parameter != null) {
      TypeHandler innerHandler=getHandlerFor(parameter,depth);
      if (innerHandler != null) {
        return new ListTypeHandler(innerHandler);
      }
    }
    logger.error("List field is not parameterized, or holds unsupported type");
    return null;
  }
 else   if (Set.class.isAssignableFrom(typeClass)) {
    Type parameter=getTypeParameter(type,0);
    if (parameter != null) {
      TypeHandler innerHandler=getHandlerFor(parameter,depth);
      if (innerHandler != null) {
        return new SetTypeHandler(innerHandler);
      }
    }
    logger.error("Set field is not parameterized, or holds unsupported type");
    return null;
  }
 else   if (Map.class.isAssignableFrom(typeClass)) {
    Type keyParameter=getTypeParameter(type,0);
    Type contentsParameter=getTypeParameter(type,1);
    if (keyParameter != null && contentsParameter != null && String.class == keyParameter) {
      TypeHandler valueHandler=getHandlerFor(contentsParameter,depth);
      if (valueHandler != null) {
        return new StringMapTypeHandler(valueHandler);
      }
    }
    logger.error("Map field is not parameterized, does not have a String key, or holds unsupported values");
  }
 else   if (typeHandlers.containsKey(typeClass)) {
    return typeHandlers.get(typeClass);
  }
 else   if (depth <= MAX_SERIALIZATION_DEPTH && !Modifier.isAbstract(typeClass.getModifiers()) && !typeClass.isLocalClass() && !(typeClass.isMemberClass() && !Modifier.isStatic(typeClass.getModifiers()))) {
    try {
      typeClass.getConstructor();
    }
 catch (    NoSuchMethodException e) {
      logger.error("Unable to register field of type {}: no publicly accessible default constructor",typeClass.getSimpleName());
      return null;
    }
    logger.warn("Handling serialization of type {} via MappedContainer",typeClass);
    MappedContainerTypeHandler mappedHandler=new MappedContainerTypeHandler(typeClass);
    for (    Field field : typeClass.getDeclaredFields()) {
      if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers()))       continue;
      field.setAccessible(true);
      TypeHandler handler=getHandlerFor(field.getGenericType(),depth + 1);
      if (handler == null) {
        logger.error("Unsupported field type in component type {}, {} : {}",typeClass.getSimpleName(),field.getName(),field.getGenericType());
      }
 else {
        mappedHandler.addField(new FieldMetadata(field,typeClass,handler));
      }
    }
    return mappedHandler;
  }
  return null;
}
