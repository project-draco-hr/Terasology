{
  List<MD5Joint> md5JointList=new ArrayList<MD5Joint>();
  List<MD5Mesh> md5MeshList=new ArrayList<MD5Mesh>();
  skeletonBuilder=new SkeletalMeshDataBuilder();
  Map<String,MD5Joint> md5JointBySidMap=new HashMap<String,MD5Joint>();
  MD5Joint parentMD5Joint=null;
  ElementSet nodeParentSet=rootElement.find("library_visual_scenes","visual_scene","node");
  for (  Element element : nodeParentSet) {
    createMd5JointForElementAndParent(md5JointBySidMap,element,parentMD5Joint);
  }
  ElementSet controllerSet=rootElement.find("library_controllers","controller");
  for (  Element controller : controllerSet) {
    ElementSet skinSet=controller.find("skin");
    if (1 != skinSet.size()) {
      throw new ColladaParseException("Found " + skinSet.size() + " skin sets for controller id="+ controller.id()+ " name="+ controller.name());
    }
    Element skin=skinSet.first();
    ElementSet jointsSet=skin.find("joints");
    if (1 != jointsSet.size()) {
      throw new ColladaParseException("Found " + jointsSet.size() + " joints sets for controller id="+ controller.id()+ " name="+ controller.name());
    }
    Element joints=jointsSet.first();
    ElementSet vertexWeightsSet=skin.find("vertex_weights");
    if (1 != vertexWeightsSet.size()) {
      throw new ColladaParseException("Found " + vertexWeightsSet.size() + " vertex weights sets for controller id="+ controller.id()+ " name="+ controller.name());
    }
    Element vertexWeights=vertexWeightsSet.first();
    String vertexWeightsCountString=vertexWeights.attr("count");
    int vertexWeightsCount=Integer.parseInt(vertexWeightsCountString);
    String[] jointNameArray=null;
    float[] inverseBindMatrixArray;
    Quat4f[] rotationArray;
    ElementSet jointsInputSet=joints.find("input");
    List<Input> inputList=parseInputs(jointsInputSet);
    for (    Input jointsInput : inputList) {
      if ("JOINT".equals(jointsInput.semantic)) {
        Element jointNameSourceElement=skin.select(jointsInput.sourceName);
        Source jointNameSource=parseSource(jointNameSourceElement);
        jointNameArray=jointNameSource.nameValues;
      }
      if ("INV_BIND_MATRIX".equals(jointsInput.semantic)) {
        Element jointMatrixSourceElement=skin.select(jointsInput.sourceName);
        Source jointMatrixSource=parseSource(jointMatrixSourceElement);
        inverseBindMatrixArray=jointMatrixSource.floatValues;
        rotationArray=quad4fArrayFromFloat16ArrayData(inverseBindMatrixArray);
      }
    }
    List<MD5Weight> md5WeightList=Lists.newArrayList();
    float[] weightsArray=null;
    ElementSet vertexWeightsInputSet=vertexWeights.find("input");
    List<Input> vertexWeightsInputList=parseInputs(vertexWeightsInputSet);
    Collections.sort(vertexWeightsInputList,new Comparator<Input>(){
      @Override public int compare(      Input i1,      Input i2){
        return i1.offset - i2.offset;
      }
    }
);
    for (int i=0; i < vertexWeightsInputList.size(); i++) {
      Input input=vertexWeightsInputList.get(i);
      if (input.offset != i) {
        throw new ColladaParseException("vertex weights input list offset does not match list index for vertex weights input " + input + " for controller id="+ controller.id()+ " name="+ controller.name());
      }
    }
    for (    Input vertexWeightsInput : vertexWeightsInputList) {
      if ("WEIGHT".equals(vertexWeightsInput.semantic)) {
        Element jointMatrixSourceElement=skin.select(vertexWeightsInput.sourceName);
        Source weightsArraySource=parseSource(jointMatrixSourceElement);
        weightsArray=weightsArraySource.floatValues;
      }
    }
    ElementSet vertexWeightsVCountDataSet=vertexWeights.find("vcount");
    if (1 != vertexWeightsVCountDataSet.size()) {
      throw new ColladaParseException("Found " + vertexWeightsVCountDataSet.size() + " vertex weights vcount sets for controller id="+ controller.id()+ " name="+ controller.name());
    }
    Element vertexWeightsVCountData=vertexWeightsVCountDataSet.first();
    String vertexWeightsVCountString=vertexWeightsVCountData.text();
    String[] vertexWeightsVCountStrings=getItemsInString(vertexWeightsVCountString);
    if (vertexWeightsVCountStrings.length != vertexWeightsCount) {
      throw new ColladaParseException("Expected " + vertexWeightsCount + " but was "+ vertexWeightsVCountStrings.length+ " for controller id="+ controller.id()+ " name="+ controller.name());
    }
    ElementSet vertexWeightsVDataSet=vertexWeights.find("v");
    if (1 != vertexWeightsVDataSet.size()) {
      throw new ColladaParseException("Found " + vertexWeightsVDataSet.size() + " vertex weights v sets for controller id="+ controller.id()+ " name="+ controller.name());
    }
    Element vertexWeightsVData=vertexWeightsVDataSet.first();
    String vertexWeightsVDataString=vertexWeightsVData.text();
    String[] vertexWeightsVStrings=getItemsInString(vertexWeightsVDataString);
    String[] vertexWeightsJointNameArray=new String[vertexWeightsCount];
    float[] vertexWeightsArray=new float[vertexWeightsCount];
    int vertexWeightsVDataIndex=-1;
    for (int vertexWeightsIndex=0; vertexWeightsIndex < vertexWeightsCount; vertexWeightsIndex++) {
      MD5Weight md5Weight=new MD5Weight();
      Vector3f vertexPosition=new Vector3f();
      vertexPosition.x=vertices.get(3 * vertexWeightsIndex + 0);
      vertexPosition.y=vertices.get(3 * vertexWeightsIndex + 1);
      vertexPosition.z=vertices.get(3 * vertexWeightsIndex + 2);
      md5Weight.position=vertexPosition;
      md5WeightList.add(md5Weight);
      String vCountString=vertexWeightsVCountStrings[vertexWeightsIndex];
      int vCount=Integer.parseInt(vCountString);
      for (int vCountIndex=0; vCountIndex < vCount; vCountIndex++) {
        for (int vertexWeightsInputOffset=0; vertexWeightsInputOffset < vertexWeightsInputList.size(); vertexWeightsInputOffset++) {
          Input vertexWeightsInput=vertexWeightsInputList.get(vertexWeightsInputOffset);
          ++vertexWeightsVDataIndex;
          String indexString=vertexWeightsVStrings[vertexWeightsVDataIndex];
          int index=Integer.parseInt(indexString);
          if (-1 == index) {
            throw new ColladaParseException("We do not support indexing into the bind shape yet");
          }
          if ("JOINT".equals(vertexWeightsInput.semantic)) {
            md5Weight.jointIndex=index;
            vertexWeightsJointNameArray[vertexWeightsIndex]=jointNameArray[index];
          }
 else           if ("WEIGHT".equals(vertexWeightsInput.semantic)) {
            md5Weight.bias=weightsArray[index];
            vertexWeightsArray[vertexWeightsIndex]=weightsArray[index];
          }
 else {
            throw new ColladaParseException("Found unexpected vertex weights Input semantic " + vertexWeightsInput.semantic + " for controller id="+ controller.id()+ " name="+ controller.name());
          }
        }
      }
    }
    MD5Mesh md5Mesh=new MD5Mesh();
    md5Mesh.weightList=md5WeightList;
    for (    String jointName : jointNameArray) {
      MD5Joint md5Joint=md5JointBySidMap.get(jointName);
      if (null == md5Joint) {
        throw new ColladaParseException("Cannot find joint node for node sid value for joint " + jointName + " in nodes for library_visual_scenes");
      }
      md5JointList.add(md5Joint);
    }
  }
  Deque<MD5Joint> jointsToProcess=new LinkedList<MD5Joint>(md5JointList);
  while (!jointsToProcess.isEmpty()) {
    MD5Joint joint=jointsToProcess.pop();
    MD5Joint parentJoint=joint.parent;
    if (null != parentJoint) {
      if (!md5JointList.contains(parentJoint)) {
        md5JointList.add(parentJoint);
        jointsToProcess.push(parentJoint);
      }
    }
  }
  for (  MD5Joint joint : md5JointList) {
    if (null == joint.position) {
      throw new ColladaParseException("no joint position for joint with element id " + joint.element.id());
    }
    if (null == joint.orientation) {
      throw new ColladaParseException("no joint orientation for joint with element id " + joint.element.id());
    }
    joint.bone=new Bone(-1,joint.name,joint.position,joint.orientation);
  }
  for (  MD5Joint joint : md5JointList) {
    for (    MD5Joint childJoint : joint.childList) {
      if (null != childJoint.bone) {
        joint.bone.addChild(childJoint.bone);
      }
    }
  }
  for (  MD5Joint joint : md5JointList) {
    skeletonBuilder.addBone(joint.bone);
  }
  if (md5MeshList.size() > 0) {
    MD5Mesh mesh=md5MeshList.get(0);
    for (    MD5Weight weight : mesh.weightList) {
      skeletonBuilder.addWeight(new BoneWeight(weight.position,weight.bias,weight.jointIndex));
    }
    List<Vector2f> uvs=Lists.newArrayList();
    TIntList vertexStartWeight=new TIntArrayList(vertices.size() / 3);
    TIntList vertexWeightCount=new TIntArrayList(vertices.size() / 3);
    for (int i=0; i < vertices.size() / 3; i++) {
      vertexStartWeight.add(i);
      vertexWeightCount.add(1);
    }
    skeletonBuilder.setVertexWeights(vertexStartWeight,vertexWeightCount);
    for (int i=0; i < normals.size() / 2; i++) {
      uvs.add(new Vector2f(normals.get(i * 2 + 0),normals.get(i * 2 + 1)));
    }
    skeletonBuilder.setUvs(uvs);
    skeletonBuilder.setIndices(indices);
  }
}
