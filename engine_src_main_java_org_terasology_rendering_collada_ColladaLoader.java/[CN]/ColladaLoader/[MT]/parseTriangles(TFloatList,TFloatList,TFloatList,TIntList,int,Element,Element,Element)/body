{
  int vertCount=vertCountParam;
  String triangleCountString=triangles.attr("count");
  int triangleCount=Integer.parseInt(triangleCountString);
  ElementSet triangleInputSet=triangles.find("input");
  List<Input> triangleInputs=parseInputs(triangleInputSet);
  for (  Input triangleInput : triangleInputs) {
    if ("VERTEX".equals(triangleInput.semantic)) {
      ElementSet verticesSet=mesh.find("vertices");
      if (1 != verticesSet.size()) {
        throw new ColladaParseException("Found " + verticesSet.size() + " vertices sets for geometry id="+ geometry.id()+ " name="+ geometry.name());
      }
      Element verticesElement=verticesSet.first();
      ElementSet verticesInputSet=verticesElement.find("input");
      List<Input> verticesInputs=parseInputs(verticesInputSet);
      for (      Input vertexInput : verticesInputs) {
        if ("POSITION".equals(vertexInput.semantic)) {
          Element vertexSourceElement=mesh.select(vertexInput.sourceName);
          triangleInput.vertexPositionSource=parseSource(vertexSourceElement);
        }
 else         if ("NORMAL".equals(vertexInput.semantic)) {
          Element normalSourceElement=mesh.select(vertexInput.sourceName);
          triangleInput.vertexNormalSource=parseSource(normalSourceElement);
        }
 else {
          throw new ColladaParseException("Found unexpected vertex Input semantic " + vertexInput.semantic + " for geometry id="+ geometry.id()+ " name="+ geometry.name());
        }
      }
    }
 else     if ("NORMAL".equals(triangleInput.semantic)) {
      Element normalSourceElement=mesh.select(triangleInput.sourceName);
      triangleInput.normalSource=parseSource(normalSourceElement);
      if (3 != triangleInput.normalSource.stride) {
        throw new ColladaParseException("Found stride of " + triangleInput.normalSource.stride + " for triangle Input semantic "+ triangleInput.semantic+ " for geometry id="+ geometry.id()+ " name="+ geometry.name());
      }
    }
 else     if ("TEXCOORD".equals(triangleInput.semantic)) {
      Element texCoordSourceElement=mesh.select(triangleInput.sourceName);
      triangleInput.texCoordSource=parseSource(texCoordSourceElement);
    }
 else {
      throw new ColladaParseException("Found unexpected triangle Input semantic " + triangleInput.semantic + " for geometry id="+ geometry.id()+ " name="+ geometry.name());
    }
  }
  ElementSet triangleDataSet=triangles.find("p");
  if (1 != triangleDataSet.size()) {
    throw new ColladaParseException("Found " + triangleDataSet.size() + " triangleData sets for geometry id="+ geometry.id()+ " name="+ geometry.name());
  }
  Element triangleData=triangleDataSet.first();
  String triangleDataString=triangleData.text();
  String[] trianglesStrings=getItemsInString(triangleDataString);
  if (trianglesStrings.length != (triangleCount * triangleInputs.size() * 3)) {
    throw new ColladaParseException("Expected String 3 vertices *  " + triangleCount + " * input count of "+ triangleInputs.size()+ " but was "+ trianglesStrings.length+ " for geometry id="+ geometry.id()+ " name="+ geometry.name());
  }
  Collections.sort(triangleInputs,new Comparator<Input>(){
    @Override public int compare(    Input i1,    Input i2){
      return i1.offset - i2.offset;
    }
  }
);
  for (int i=0; i < triangleInputs.size(); i++) {
    Input input=triangleInputs.get(i);
    if (input.offset != i) {
      throw new ColladaParseException("Triangle input list offset does not match list index for triangle input " + input + " for geometry id="+ geometry.id()+ " name="+ geometry.name());
    }
  }
  for (int triangleIndex=0; triangleIndex < triangleCount; triangleIndex++) {
    for (int triangleVertexIndex=0; triangleVertexIndex < 3; triangleVertexIndex++) {
      for (int triangleInputOffset=0; triangleInputOffset < triangleInputs.size(); triangleInputOffset++) {
        Input triangleInput=triangleInputs.get(triangleInputOffset);
        int triangleDataIndex=(triangleIndex * triangleInputs.size() * 3) + (triangleVertexIndex * triangleInputs.size()) + triangleInputOffset;
        String indexString=trianglesStrings[triangleDataIndex];
        int index=Integer.parseInt(indexString);
        if ("VERTEX".equals(triangleInput.semantic)) {
          int vertexStride=triangleInput.vertexPositionSource.stride;
          if (3 != vertexStride) {
            throw new ColladaParseException("Found non-3 stride of " + triangleInput.vertexPositionSource.stride + " for vertex Input semantic "+ triangleInput.semantic+ " for geometry id="+ geometry.id()+ " name="+ geometry.name());
          }
          float vertexX=triangleInput.vertexPositionSource.floatValues[index * vertexStride + 0];
          float vertexY=triangleInput.vertexPositionSource.floatValues[index * vertexStride + 1];
          float vertexZ=triangleInput.vertexPositionSource.floatValues[index * vertexStride + 2];
          verticesParam.add(vertexX);
          verticesParam.add(vertexY);
          verticesParam.add(vertexZ);
          if (null != triangleInput.vertexNormalSource) {
            int normalStride=triangleInput.vertexNormalSource.stride;
            if (3 != normalStride) {
              throw new ColladaParseException("Found non-3 stride of " + triangleInput.vertexNormalSource.stride + " for vertex Input semantic "+ triangleInput.semantic+ " for geometry id="+ geometry.id()+ " name="+ geometry.name());
            }
            float normalX=triangleInput.vertexNormalSource.floatValues[index * normalStride + 0];
            float normalY=triangleInput.vertexNormalSource.floatValues[index * normalStride + 1];
            float normalZ=triangleInput.vertexNormalSource.floatValues[index * normalStride + 2];
            normalsParam.add(normalX);
            normalsParam.add(normalY);
            normalsParam.add(normalZ);
          }
          indicesParam.add(vertCount++);
        }
 else         if ("NORMAL".equals(triangleInput.semantic)) {
          int normalStride=triangleInput.normalSource.stride;
          if (3 != normalStride) {
            throw new ColladaParseException("Found non-3 stride of " + triangleInput.normalSource.stride + " for vertex Input semantic "+ triangleInput.semantic+ " for geometry id="+ geometry.id()+ " name="+ geometry.name());
          }
          float normalX=triangleInput.normalSource.floatValues[index * normalStride + 0];
          float normalY=triangleInput.normalSource.floatValues[index * normalStride + 1];
          float normalZ=triangleInput.normalSource.floatValues[index * normalStride + 2];
          normalsParam.add(normalX);
          normalsParam.add(normalY);
          normalsParam.add(normalZ);
        }
 else         if ("TEXCOORD".equals(triangleInput.semantic)) {
          int texCoordStride=triangleInput.texCoordSource.stride;
          if (2 != texCoordStride) {
            throw new ColladaParseException("Found non-2 stride of " + triangleInput.texCoordSource.stride + " for vertex Input semantic "+ triangleInput.semantic+ " for geometry id="+ geometry.id()+ " name="+ geometry.name());
          }
          float texCoordS=triangleInput.texCoordSource.floatValues[index * texCoordStride + 0];
          float texCoordT=triangleInput.texCoordSource.floatValues[index * texCoordStride + 1];
          texCoord0Param.add(texCoordS);
          texCoord0Param.add(1 - texCoordT);
        }
 else {
          throw new ColladaParseException("Found unexpected triangle Input semantic " + triangleInput.semantic + " for geometry id="+ geometry.id()+ " name="+ geometry.name());
        }
      }
    }
  }
  return vertCount;
}
