{
  String axiom=initialAxiom;
  Stack<Vector3f> stackPosition=new Stack<Vector3f>();
  Stack<Matrix4f> stackOrientation=new Stack<Matrix4f>();
  for (int i=0; i < iterations; i++) {
    String temp="";
    for (int j=0; j < axiom.length(); j++) {
      String c=String.valueOf(axiom.charAt(j));
      double rValue=(rand.randomDouble() + 1.0) / 2.0;
      if (ruleSet.containsKey(c) && probabilities.get(c) > (1.0 - rValue)) {
        temp+=ruleSet.get(c);
      }
 else {
        temp+=c;
      }
    }
    axiom=temp;
  }
  Vector3f position=new Vector3f(0,0,0);
  Matrix4f rotation=new Matrix4f();
  rotation.setIdentity();
  rotation.setRotation(new AxisAngle4f(new Vector3f(0,0,1),(float)Math.PI / 2.0f));
  int angleOffset=rand.randomInt() % MAX_ANGLE_OFFSET;
  for (int i=0; i < axiom.length(); i++) {
    char c=axiom.charAt(i);
    Matrix4f tempRotation=new Matrix4f();
    tempRotation.setIdentity();
switch (c) {
case 'G':
case 'F':
      view.setBlock(posX + (int)position.x + 1,posY + (int)position.y,posZ + (int)position.z,barkType);
    view.setBlock(posX + (int)position.x - 1,posY + (int)position.y,posZ + (int)position.z,barkType);
  view.setBlock(posX + (int)position.x,posY + (int)position.y,posZ + (int)position.z + 1,barkType);
view.setBlock(posX + (int)position.x,posY + (int)position.y,posZ + (int)position.z - 1,barkType);
if (stackOrientation.size() > 1) {
int size=1;
for (int x=-size; x <= size; x++) {
  for (int y=-size; y <= size; y++) {
    for (int z=-size; z <= size; z++) {
      if (Math.abs(x) == size && Math.abs(y) == size && Math.abs(z) == size) {
        continue;
      }
      view.setBlock(posX + (int)position.x + x+ 1,posY + (int)position.y + y,posZ + z + (int)position.z,leafType);
      view.setBlock(posX + (int)position.x + x - 1,posY + (int)position.y + y,posZ + z + (int)position.z,leafType);
      view.setBlock(posX + (int)position.x + x,posY + (int)position.y + y,posZ + z + (int)position.z+ 1,leafType);
      view.setBlock(posX + (int)position.x + x,posY + (int)position.y + y,posZ + z + (int)position.z - 1,leafType);
    }
  }
}
}
Vector3f dir=new Vector3f(1,0,0);
rotation.transform(dir);
position.add(dir);
break;
case '[':
stackOrientation.push(new Matrix4f(rotation));
stackPosition.push(new Vector3f(position));
break;
case ']':
rotation=stackOrientation.pop();
position=stackPosition.pop();
break;
case '+':
tempRotation.setIdentity();
tempRotation.setRotation(new AxisAngle4f(new Vector3f(0,0,1),(float)Math.toRadians(angleInDegree + angleOffset)));
rotation.mul(tempRotation);
break;
case '-':
tempRotation.setIdentity();
tempRotation.setRotation(new AxisAngle4f(new Vector3f(0,0,-1),(float)Math.toRadians(angleInDegree + angleOffset)));
rotation.mul(tempRotation);
break;
case '&':
tempRotation.setIdentity();
tempRotation.setRotation(new AxisAngle4f(new Vector3f(0,1,0),(float)Math.toRadians(angleInDegree + angleOffset)));
rotation.mul(tempRotation);
break;
case '^':
tempRotation.setIdentity();
tempRotation.setRotation(new AxisAngle4f(new Vector3f(0,-1,0),(float)Math.toRadians(angleInDegree + angleOffset)));
rotation.mul(tempRotation);
break;
case '*':
tempRotation.setIdentity();
tempRotation.setRotation(new AxisAngle4f(new Vector3f(1,0,0),(float)Math.toRadians(angleInDegree)));
rotation.mul(tempRotation);
break;
case '/':
tempRotation.setIdentity();
tempRotation.setRotation(new AxisAngle4f(new Vector3f(-1,0,0),(float)Math.toRadians(angleInDegree)));
rotation.mul(tempRotation);
break;
}
}
}
