{
  statDirtyChunks=0;
  statVisibleChunks=0;
  statIgnoredPhases=0;
  if (processChunkUpdates) {
    PerformanceMonitor.startActivity("Building Mesh VBOs");
    chunkMeshUpdateManager.setCameraPosition(activeCamera.getPosition());
    for (    RenderableChunk chunk : chunkMeshUpdateManager.availableChunksForUpdate()) {
      if (chunksInProximityOfCamera.contains(chunk) && chunk.getPendingMesh() != null) {
        for (int i=0; i < chunk.getPendingMesh().length; i++) {
          chunk.getPendingMesh()[i].generateVBOs();
        }
        if (chunk.getMesh() != null) {
          for (int i=0; i < chunk.getMesh().length; i++) {
            chunk.getMesh()[i].dispose();
          }
        }
        chunk.setMesh(chunk.getPendingMesh());
        chunk.setPendingMesh(null);
      }
 else {
        ChunkMesh[] pendingMesh=chunk.getPendingMesh();
        chunk.setPendingMesh(null);
        if (pendingMesh != null) {
          for (          ChunkMesh mesh : pendingMesh) {
            mesh.dispose();
          }
        }
      }
    }
    PerformanceMonitor.endActivity();
  }
  int processedChunks=0;
  for (int i=0; i < chunksInProximityOfCamera.size(); i++) {
    RenderableChunk chunk=chunksInProximityOfCamera.get(i);
    ChunkMesh[] mesh=chunk.getMesh();
    if (i < TeraMath.clamp(renderingConfig.getMaxChunksUsedForShadowMapping(),64,1024) && renderingConfig.isDynamicShadows() && fillShadowRenderQueue) {
      if (isChunkVisibleLight(chunk) && isChunkValidForRender(chunk)) {
        if (triangleCount(mesh,ChunkMesh.RenderPhase.OPAQUE) > 0) {
          renderQueues.chunksOpaqueShadow.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
      }
    }
    if (isChunkValidForRender(chunk)) {
      if (isChunkVisible(chunk)) {
        if (triangleCount(mesh,ChunkMesh.RenderPhase.OPAQUE) > 0) {
          renderQueues.chunksOpaque.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
        if (triangleCount(mesh,ChunkMesh.RenderPhase.REFRACTIVE) > 0) {
          renderQueues.chunksAlphaBlend.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
        if (triangleCount(mesh,ChunkMesh.RenderPhase.ALPHA_REJECT) > 0 && i < MAX_BILLBOARD_CHUNKS) {
          renderQueues.chunksAlphaReject.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
        statVisibleChunks++;
        if (statVisibleChunks < MAX_ANIMATED_CHUNKS) {
          chunk.setAnimated(true);
        }
 else {
          chunk.setAnimated(false);
        }
      }
      if (isChunkVisibleReflection(chunk)) {
        renderQueues.chunksOpaqueReflection.add(chunk);
      }
      if (processChunkUpdates && processChunkUpdate(chunk)) {
        processedChunks++;
      }
    }
  }
  return processedChunks;
}
