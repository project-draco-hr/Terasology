{
  statDirtyChunks=0;
  statVisibleChunks=0;
  statIgnoredPhases=0;
  if (processChunkUpdates) {
    PerformanceMonitor.startActivity("Building Mesh VBOs");
    chunkMeshUpdateManager.setCameraPosition(playerCamera.getPosition());
    for (    RenderableChunk chunk : chunkMeshUpdateManager.availableChunksForUpdate()) {
      if (chunksInProximityOfCamera.contains(chunk) && chunk.hasPendingMesh()) {
        for (        ChunkMesh pendingMesh : chunk.getPendingMesh()) {
          pendingMesh.generateVBOs();
        }
        if (chunk.hasMesh()) {
          for (          ChunkMesh mesh : chunk.getMesh()) {
            mesh.dispose();
          }
        }
        chunk.setMesh(chunk.getPendingMesh());
        chunk.setPendingMesh(null);
      }
 else {
        if (chunk.hasPendingMesh()) {
          for (          ChunkMesh pendingMesh : chunk.getPendingMesh()) {
            pendingMesh.dispose();
          }
          chunk.setPendingMesh(null);
        }
      }
    }
    PerformanceMonitor.endActivity();
  }
  int processedChunks=0;
  int chunkCounter=0;
  ChunkMesh[] mesh;
  RenderableChunk chunk;
  boolean isDynamicShadows=renderingConfig.isDynamicShadows();
  Iterator<RenderableChunk> nearbyChunks=chunksInProximityOfCamera.iterator();
  while (nearbyChunks.hasNext()) {
    chunk=nearbyChunks.next();
    if (isChunkValidForRender(chunk)) {
      mesh=chunk.getMesh();
      if (isDynamicShadows && fillShadowRenderQueue && chunkCounter < maxChunksForShadows && isChunkVisibleLight(chunk)) {
        if (triangleCount(mesh,ChunkMesh.RenderPhase.OPAQUE) > 0) {
          renderQueues.chunksOpaqueShadow.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
      }
      if (isChunkVisible(chunk)) {
        if (triangleCount(mesh,ChunkMesh.RenderPhase.OPAQUE) > 0) {
          renderQueues.chunksOpaque.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
        if (triangleCount(mesh,ChunkMesh.RenderPhase.REFRACTIVE) > 0) {
          renderQueues.chunksAlphaBlend.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
        if (triangleCount(mesh,ChunkMesh.RenderPhase.ALPHA_REJECT) > 0 && chunkCounter < MAX_BILLBOARD_CHUNKS) {
          renderQueues.chunksAlphaReject.add(chunk);
        }
 else {
          statIgnoredPhases++;
        }
        statVisibleChunks++;
        if (statVisibleChunks < MAX_ANIMATED_CHUNKS) {
          chunk.setAnimated(true);
        }
 else {
          chunk.setAnimated(false);
        }
      }
      if (isChunkVisibleReflection(chunk)) {
        renderQueues.chunksOpaqueReflection.add(chunk);
      }
      if (processChunkUpdates && processChunkUpdate(chunk)) {
        processedChunks++;
      }
    }
    chunkCounter++;
  }
  return processedChunks;
}
