{
  boolean result=false;
  List<BlockPosition> blockPositions=WorldUtil.gatherAdjacentBlockPositions(origin);
  for (int i=0; i < blockPositions.size(); i++) {
    BlockPosition p=blockPositions.get(i);
    Block block=worldProvider.getBlock(p);
    if (!block.isPenetrable()) {
      AABB blockAABB=block.getBounds(p);
      if (calcAABB(position,extents).overlaps(blockAABB)) {
        result=true;
        Vector3d direction=new Vector3d(position.x,0f,position.z);
        direction.x-=origin.x;
        direction.z-=origin.z;
        Vector3d blockPoi=blockAABB.closestPointOnAABBToPoint(new Vector3d(origin));
        Vector3d entityPoi=calcAABB(origin,extents).closestPointOnAABBToPoint(blockPoi);
        Vector3d planeNormal=blockAABB.getFirstHitPlane(direction,new Vector3d(origin),new Vector3d(extents),true,false,true);
        Vector3d slideVector=new Vector3d(planeNormal.z,0,-planeNormal.x);
        Vector3d pushBack=new Vector3d();
        pushBack.sub(blockPoi,entityPoi);
        double length=slideVector.dot(direction);
        Vector3d newPosition=new Vector3d();
        newPosition.z=origin.z + pushBack.z * 0.2 + length * slideVector.z;
        newPosition.x=origin.x + pushBack.x * 0.2 + length * slideVector.x;
        newPosition.y=origin.y;
        position.set(newPosition);
      }
    }
  }
  return result;
}
