{
  this.farStore=farStore;
  this.generator=generator;
  logger.info("CACHE_SIZE = {} for nearby chunks",CACHE_SIZE);
  reviewChunkQueue=new PriorityBlockingQueue<ChunkRequest>(32);
  reviewThreads=Executors.newFixedThreadPool(REQUEST_CHUNK_THREADS);
  for (int i=0; i < REQUEST_CHUNK_THREADS; ++i) {
    reviewThreads.execute(new Runnable(){
      @Override public void run(){
        boolean running=true;
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        while (running) {
          try {
            ChunkRequest request=reviewChunkQueue.take();
switch (request.getType()) {
case REVIEW:
              for (              Vector3i pos : request.getRegion()) {
                checkState(pos);
              }
            break;
case PRODUCE:
          for (          Vector3i pos : request.getRegion()) {
            checkOrCreateChunk(pos);
          }
        break;
case EXIT:
      running=false;
    break;
}
}
 catch (InterruptedException e) {
logger.error("Thread interrupted",e);
}
catch (Exception e) {
logger.error("Error in thread",e);
}
}
logger.debug("Thread shutdown safely");
}
}
);
}
chunkTasksQueue=new PriorityBlockingQueue<ChunkTask>(128,new ChunkTaskRelevanceComparator());
chunkProcessingThreads=Executors.newFixedThreadPool(CHUNK_PROCESSING_THREADS);
for (int i=0; i < CHUNK_PROCESSING_THREADS; ++i) {
chunkProcessingThreads.submit(new Runnable(){
@Override public void run(){
boolean running=true;
Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
while (running) {
try {
ChunkTask request=chunkTasksQueue.take();
if (request.isShutdownRequest()) {
  running=false;
  break;
}
request.enact();
}
 catch (InterruptedException e) {
logger.error("Thread interrupted",e);
}
catch (Exception e) {
logger.error("Error in thread",e);
}
}
logger.debug("Thread shutdown safely");
}
}
);
}
}
