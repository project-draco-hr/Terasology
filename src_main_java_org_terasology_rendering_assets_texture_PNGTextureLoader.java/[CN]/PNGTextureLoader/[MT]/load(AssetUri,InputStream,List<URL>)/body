{
  InputStream pngStream=null;
  if (urls.get(0).toString().endsWith(".png")) {
    pngStream=stream;
  }
 else {
    for (    URL url : urls) {
      if (url.toString().endsWith(".png")) {
        pngStream=url.openStream();
        break;
      }
    }
  }
  if (pngStream == null) {
    throw new IOException("Missing png to go with texture json");
  }
  try {
    PNGDecoder decoder=new PNGDecoder(pngStream);
    ByteBuffer buf=ByteBuffer.allocateDirect(4 * decoder.getWidth() * decoder.getHeight());
    decoder.decode(buf,decoder.getWidth() * 4,PNGDecoder.RGBA);
    buf.flip();
    ByteBuffer data=buf;
    int height=decoder.getHeight();
    int width=decoder.getWidth();
    Texture.FilterMode filterMode=Texture.FilterMode.Nearest;
    Texture.WrapMode wrapMode=Texture.WrapMode.Clamp;
    Texture.Type type=Texture.Type.TEXTURE2D;
    if (urls.get(0).toString().contains("/fonts/")) {
      filterMode=Texture.FilterMode.Linear;
    }
    for (    URL url : urls) {
      if (url.toString().endsWith(".json")) {
        try (InputStreamReader reader=new InputStreamReader(url.openStream())){
          TextureMetadata metadata=gson.fromJson(reader,TextureMetadata.class);
          if (metadata.filterMode != null) {
            filterMode=metadata.filterMode;
          }
          if (metadata.wrapMode != null) {
            wrapMode=metadata.wrapMode;
          }
          if (metadata.type != null) {
            type=metadata.type;
          }
        }
         break;
      }
    }
    if (type == Texture.Type.TEXTURE3D) {
      final int byteLength=4 * 16 * 16* 16;
      final int strideX=16 * 4;
      final int strideY=16 * 16 * 4;
      final int strideZ=4;
      if (width % height != 0 || width / height != height) {
        throw new RuntimeException("3D texture must be cubic (height^3) - width must thus be a multiple of height");
      }
      ByteBuffer alignedBuffer=ByteBuffer.allocateDirect(byteLength);
      for (int x=0; x < height; x++) {
        for (int y=0; y < height; y++) {
          for (int z=0; z < height; z++) {
            final int index=x * strideX + z * strideZ + strideY * y;
            alignedBuffer.put(data.get(index));
            alignedBuffer.put(data.get(index + 1));
            alignedBuffer.put(data.get(index + 2));
            alignedBuffer.put(data.get(index + 3));
          }
        }
      }
      alignedBuffer.flip();
      return new TextureData(height,height,height,new ByteBuffer[]{alignedBuffer},wrapMode,filterMode);
    }
 else {
      return new TextureData(width,height,new ByteBuffer[]{data},wrapMode,filterMode);
    }
  }
  finally {
    pngStream.close();
  }
}
