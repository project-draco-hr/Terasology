{
  HierarchicalAIComponent ai=entity.getComponent(HierarchicalAIComponent.class);
  long tempTime=CoreRegistry.get(Timer.class).getTimeInMs();
  long lastAttack=0;
  if (tempTime - ai.lastProgressedUpdateAt < ai.updateFrequency) {
    ai.lastProgressedUpdateAt=CoreRegistry.get(Timer.class).getTimeInMs();
    return;
  }
  long directionChangeTime=ai.moveUpdateTime, moveChangeTime=ai.moveUpdateTime, idleChangeTime=ai.idlingUpdateTime, dangerChangeTime=ai.dangerUpdateTime;
  Vector3f drive=new Vector3f();
  LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
  if (localPlayer != null) {
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(localPlayer.getPosition());
    double distanceToPlayer=dist.lengthSquared();
    ai.inDanger=false;
    if (ai.dieIfPlayerFar)     if (distanceToPlayer > ai.dieDistance)     entity.destroy();
    if (ai.aggressive)     if (distanceToPlayer <= ai.attackDistance) {
      if (tempTime - lastAttack > ai.damageFrequency) {
        localPlayer.getCharacterEntity().send(new DamageEvent(ai.damage,entity));
        lastAttack=CoreRegistry.get(Timer.class).getTimeInMs();
      }
    }
    if (tempTime - ai.lastChangeOfDangerAt > dangerChangeTime) {
      dangerChangeTime=(long)(TeraMath.fastAbs(ai.dangerUpdateTime * random.randomDouble() * ai.hectic));
      if (ai.hunter)       if (distanceToPlayer > ai.playerdistance && distanceToPlayer < ai.playerSense) {
        Vector3f tempTarget=localPlayer.getPosition();
        if (ai.forgiving != 0)         ai.movementTarget.set(new Vector3f((tempTarget.x + random.randomFloat() * ai.forgiving),(tempTarget.y + random.randomFloat() * ai.forgiving),(tempTarget.z + random.randomFloat() * ai.forgiving)));
 else         ai.movementTarget.set(tempTarget);
        ai.inDanger=true;
        entity.saveComponent(ai);
      }
      if (ai.wild)       if (distanceToPlayer > ai.panicDistance && distanceToPlayer < ai.runDistance) {
        Vector3f tempTarget=localPlayer.getPosition();
        if (ai.forgiving != 0)         ai.movementTarget.set(new Vector3f((tempTarget.x * -1 + random.randomFloat() * ai.forgiving),(tempTarget.y * -1 + random.randomFloat() * ai.forgiving),(tempTarget.z * -1 + random.randomFloat() * ai.forgiving)));
 else         ai.movementTarget.set(new Vector3f(tempTarget.x * -1,tempTarget.y * -1,tempTarget.z * -1));
        entity.saveComponent(ai);
        ai.inDanger=true;
      }
      ai.lastChangeOfDangerAt=CoreRegistry.get(Timer.class).getTimeInMs();
    }
  }
  if (!ai.inDanger) {
    if (foodInFront()) {
      return;
    }
    if (idling) {
      if (tempTime - ai.lastChangeOfidlingtAt > idleChangeTime) {
        idleChangeTime=(long)(TeraMath.fastAbs(ai.idlingUpdateTime * random.randomDouble() * ai.hectic));
        idling=false;
        ai.lastChangeOfidlingtAt=CoreRegistry.get(Timer.class).getTimeInMs();
      }
      entity.saveComponent(location);
      ai.lastProgressedUpdateAt=CoreRegistry.get(Timer.class).getTimeInMs();
      return;
    }
    if (tempTime - ai.lastChangeOfMovementAt > moveChangeTime) {
      moveChangeTime=(long)(TeraMath.fastAbs(ai.moveUpdateTime * random.randomDouble() * ai.hectic));
      idling=true;
      entity.saveComponent(location);
      ai.lastChangeOfMovementAt=CoreRegistry.get(Timer.class).getTimeInMs();
      ai.lastProgressedUpdateAt=CoreRegistry.get(Timer.class).getTimeInMs();
      return;
    }
    if (tempTime - ai.lastChangeOfDirectionAt > directionChangeTime) {
      directionChangeTime=(long)(TeraMath.fastAbs(ai.moveUpdateTime * random.randomDouble() * ai.straightLined));
      if (ai.flying) {
        float targetY=0;
        do {
          targetY=worldPos.y + random.randomFloat() * 100;
        }
 while (targetY > ai.maxAltitude);
        ai.movementTarget.set(worldPos.x + random.randomFloat() * 500,targetY,worldPos.z + random.randomFloat() * 500);
      }
 else       ai.movementTarget.set(worldPos.x + random.randomFloat() * 500,worldPos.y,worldPos.z + random.randomFloat() * 500);
      ai.lastChangeOfDirectionAt=timer.getTimeInMs();
      entity.saveComponent(ai);
    }
  }
  Vector3f targetDirection=new Vector3f();
  targetDirection.sub(ai.movementTarget,worldPos);
  targetDirection.normalize();
  drive.set(targetDirection);
  float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
  entity.send(new CharacterMoveInputEvent(0,0,yaw,drive,false,false));
  entity.saveComponent(location);
  ai.lastProgressedUpdateAt=CoreRegistry.get(Timer.class).getTimeInMs();
}
