{
  if (material == null) {
    logger.warn("Attempted to draw with nonexistent material");
    return;
  }
  if (mesh == null) {
    logger.warn("Attempted to draw nonexistent mesh");
    return;
  }
  if (!state.cropRegion.overlaps(relativeToAbsolute(region))) {
    return;
  }
  AABB meshAABB=mesh.getAABB();
  Vector3f meshExtents=meshAABB.getExtents();
  float fitScale=0.35f * Math.min(region.width(),region.height()) / Math.max(meshExtents.x,Math.max(meshExtents.y,meshExtents.z));
  Vector3f centerOffset=meshAABB.getCenter();
  centerOffset.scale(-1.0f);
  Matrix4f centerTransform=new Matrix4f(Quat4fUtil.IDENTITY,centerOffset,1.0f);
  Matrix4f userTransform=new Matrix4f(rotation,offset,-fitScale * scale);
  Matrix4f translateTransform=new Matrix4f(Quat4fUtil.IDENTITY,new Vector3f(state.drawRegion.minX() + region.minX() + region.width() / 2,state.drawRegion.minY() + region.minY() + region.height() / 2,0),1);
  userTransform.mul(centerTransform);
  translateTransform.mul(userTransform);
  Matrix4f finalMat=new Matrix4f(modelView);
  finalMat.mul(translateTransform);
  MatrixUtils.matrixToFloatBuffer(finalMat,matrixBuffer);
  Rect2i cropRegion=relativeToAbsolute(region).intersect(state.cropRegion);
  material.setFloat4("croppingBoundaries",cropRegion.minX(),cropRegion.maxX() + 1,cropRegion.minY(),cropRegion.maxY() + 1);
  material.setMatrix4("posMatrix",translateTransform);
  glEnable(GL11.GL_DEPTH_TEST);
  glClear(GL11.GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL11.GL_MODELVIEW);
  glPushMatrix();
  glLoadMatrix(matrixBuffer);
  matrixBuffer.rewind();
  boolean matrixStackSupported=material.supportsFeature(ShaderProgramFeature.FEATURE_USE_MATRIX_STACK);
  if (matrixStackSupported) {
    material.activateFeature(ShaderProgramFeature.FEATURE_USE_MATRIX_STACK);
  }
  material.setFloat("alpha",state.getAlpha());
  material.bindTextures();
  mesh.render();
  if (matrixStackSupported) {
    material.deactivateFeature(ShaderProgramFeature.FEATURE_USE_MATRIX_STACK);
  }
  glPopMatrix();
  glDisable(GL11.GL_DEPTH_TEST);
}
