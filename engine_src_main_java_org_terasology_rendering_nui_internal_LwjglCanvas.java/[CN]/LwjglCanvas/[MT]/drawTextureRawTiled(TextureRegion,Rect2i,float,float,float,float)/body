{
  if (!state.cropRegion.overlaps(relativeToAbsolute(toArea))) {
    return;
  }
  Util.checkGLError();
  int tileW=(int)(uw * texture.getWidth());
  int tileH=(int)(uh * texture.getHeight());
  if (tileW != 0 && tileH != 0) {
    int horizTiles=TeraMath.fastAbs((toArea.width() - 1) / tileW) + 1;
    int vertTiles=TeraMath.fastAbs((toArea.height() - 1) / tileH) + 1;
    int offsetX=toArea.width() - horizTiles * tileW;
    int offsetY=toArea.height() - vertTiles * tileH;
    try (SubRegion ignored=subRegion(toArea,true)){
      for (int tileY=0; tileY < vertTiles; tileY++) {
        for (int tileX=0; tileX < horizTiles; tileX++) {
          Rect2i tileArea=Rect2i.createFromMinAndSize(toArea.minX() + offsetX + tileW * tileX,toArea.minY() + offsetY + tileH * tileY,tileW,tileH);
          drawTextureRaw(texture,tileArea,ScaleMode.STRETCH,ux,uy,uw,uh);
        }
      }
    }
   }
  Util.checkGLError();
}
