{
  ShapeSymbol axiom=new ShapeSymbol("axiom");
  ShapeSymbol house=new ShapeSymbol("house");
  ShapeSymbol floor=new ShapeSymbol("floor");
  ShapeSymbol roof=new ShapeSymbol("roof");
  SetRule setStone=new SetRule(new BlockUri("engine:cobblestone"));
  SetRule setPlank=new SetRule(new BlockUri("engine:plank"));
  SplitArg walls=new SplitArg(SplitArg.SplitType.WALLS,setStone);
  SplitRule splitWalls=new SplitRule(Arrays.asList(walls));
  DivideArg floorArg=new DivideArg(new Size(1f,false),floor);
  DivideArg roofArg=new DivideArg(new Size(1f,true),roof);
  List<DivideArg> divArgs=new ArrayList<DivideArg>(2);
  divArgs.add(floorArg);
  divArgs.add(roofArg);
  DivideRule divHouse=new DivideRule(divArgs,DivideRule.Direction.Y);
  Map<String,List<Shape>> rules=new HashMap<String,List<Shape>>();
  rules.put(axiom.getLabel(),shapeToList(house));
  rules.put(house.getLabel(),shapeToList(divHouse));
  rules.put(floor.getLabel(),shapeToList(splitWalls));
  rules.put(roof.getLabel(),shapeToList(setPlank));
  ProductionSystem system=new ProductionSystem(rules,axiom);
  Grammar grammar=new Grammar(system);
  generator=new BuildingGenerator(grammar);
  expectedBuilding=new BlockCollection();
  for (int x=0; x < size.x; x++) {
    for (int y=0; y < size.y; y++) {
      for (int z=0; z < size.z; z++) {
        if (y == size.y - 1) {
          expectedBuilding.addBlock(new BlockPosition(x,y,-z),BlockManager.getInstance().getBlock("engine:plank"));
        }
 else         if (x == 0 || x == size.x - 1 || z == 0 || z == size.z - 1) {
          expectedBuilding.addBlock(new BlockPosition(x,y,-z),BlockManager.getInstance().getBlock("engine:cobblestone"));
        }
      }
    }
  }
}
