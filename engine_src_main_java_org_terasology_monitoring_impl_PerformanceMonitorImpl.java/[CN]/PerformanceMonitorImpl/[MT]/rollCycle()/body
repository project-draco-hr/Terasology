{
  metricData.add(currentData);
  allocationData.add(currentMemData);
  spikeData.forEachEntry(new TObjectDoubleProcedure<String>(){
    public boolean execute(    String s,    double v){
      spikeData.put(s,v * DECAY_RATE);
      return true;
    }
  }
);
  currentData.forEachEntry(new TObjectLongProcedure<String>(){
    public boolean execute(    String s,    long v){
      runningTotals.adjustOrPutValue(s,v,v);
      double time=v * timeFactor;
      double prev=spikeData.get(s);
      if (time > prev) {
        spikeData.put(s,time);
      }
      return true;
    }
  }
);
  currentMemData.forEachEntry(new TObjectLongProcedure<String>(){
    public boolean execute(    String s,    long v){
      runningAllocationTotals.adjustOrPutValue(s,v,v);
      return true;
    }
  }
);
  while (metricData.size() > RETAINED_CYCLES) {
    metricData.get(0).forEachEntry(new TObjectLongProcedure<String>(){
      public boolean execute(      String s,      long v){
        runningTotals.adjustValue(s,-v);
        return true;
      }
    }
);
    metricData.remove(0);
  }
  while (allocationData.size() > RETAINED_CYCLES) {
    allocationData.get(0).forEachEntry(new TObjectLongProcedure<String>(){
      public boolean execute(      String s,      long v){
        runningAllocationTotals.adjustValue(s,-v);
        return true;
      }
    }
);
    allocationData.remove(0);
  }
  currentData=new TObjectLongHashMap<>();
  currentMemData=new TObjectLongHashMap<>();
}
