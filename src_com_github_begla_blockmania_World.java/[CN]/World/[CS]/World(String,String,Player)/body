{
  this._player=p;
  _rand=new FastRandom(seed.hashCode());
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z];
  _generatorTerrain=new GeneratorTerrain(seed);
  _generatorForest=new GeneratorForest(seed);
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
      Chunk c=loadOrCreateChunk(x,z);
      _chunks[x][0][z]=c;
      queueChunkForUpdate(c);
    }
  }
  _worldGenerated=true;
  _player.resetPlayer();
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      int itCounter=0;
      while (true) {
        long timeStart=System.currentTimeMillis();
        timeStart=System.currentTimeMillis();
synchronized (_chunkUpdateNormal) {
          Collections.sort(_chunkUpdateNormal);
        }
        if (_chunkUpdateNormal.size() > 0) {
          Chunk c=null;
synchronized (_chunkUpdateNormal) {
            c=_chunkUpdateNormal.get(0);
          }
          processChunk(c);
synchronized (_chunkUpdateNormal) {
            _chunkUpdateNormal.remove(c);
          }
        }
        updateInfWorld();
        updateDaytime();
        _statUpdateDuration+=System.currentTimeMillis() - timeStart;
        _statUpdateDuration/=2;
        itCounter++;
      }
    }
  }
);
  _updateThread.start();
}
