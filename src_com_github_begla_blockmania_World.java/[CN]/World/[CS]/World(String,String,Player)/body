{
  this._player=p;
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y];
  _title=title;
  if (_title.equals("")) {
    _title=seed;
  }
  _generatorTerrain=new ChunkGeneratorTerrain(seed);
  _generatorForest=new ChunkGeneratorForest(seed);
  _generatorTree=new ObjectGeneratorTree(this,seed);
  _generatorPineTree=new ObjectGeneratorPineTree(this,seed);
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.y; z++) {
      Chunk c=loadOrCreateChunk(x,z);
      _chunks[x][z]=c;
      queueChunkForUpdate(c);
    }
  }
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        if (!_updateThreadAlive) {
          return;
        }
        if (!_updatingEnabled) {
synchronized (_updateThread) {
            try {
              _updateThread.wait();
            }
 catch (            InterruptedException ex) {
            }
          }
        }
        long timeStart=System.currentTimeMillis();
        timeStart=System.currentTimeMillis();
        if (!_chunkUpdateNormal.isEmpty()) {
          Chunk[] chunks=_chunkUpdateNormal.toArray(new Chunk[0]);
          double dist=Float.MAX_VALUE;
          int index=-1;
          for (int i=0; i < chunks.length; i++) {
            Chunk c=chunks[i];
            double tDist=c.calcDistanceToPlayer();
            if (tDist <= dist) {
              dist=tDist;
              index=i;
            }
          }
          if (index >= 0) {
            Chunk c=(Chunk)chunks[index];
            processChunk(c);
          }
          _statUpdateDuration+=System.currentTimeMillis() - timeStart;
          _statUpdateDuration/=2;
        }
        updateInfWorld();
        updateDaytime();
        try {
          Thread.sleep(15);
        }
 catch (        InterruptedException ex) {
          Logger.getLogger(World.class.getName()).log(Level.SEVERE,null,ex);
        }
      }
    }
  }
);
}
