{
  this._player=p;
  _title=title;
  _seed=seed;
  if (_title.equals("")) {
    _title=seed;
  }
  _generatorTerrain=new ChunkGeneratorTerrain(seed);
  _generatorForest=new ChunkGeneratorForest(seed);
  _generatorTree=new ObjectGeneratorTree(this,seed);
  _generatorPineTree=new ObjectGeneratorPineTree(this,seed);
  _generatorGrass=new ChunkGeneratorFlora(seed);
  _rand=new FastRandom(seed.hashCode());
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        if (!_updateThreadAlive) {
          return;
        }
        if (!_updatingEnabled) {
synchronized (_updateThread) {
            try {
              _updateThread.wait();
            }
 catch (            InterruptedException ex) {
              Logger.getLogger(World.class.getName()).log(Level.SEVERE,ex.toString());
            }
          }
        }
        if (_chunkUpdateQueueDL.size() > 32) {
          continue;
        }
        long timeStart=System.currentTimeMillis();
        timeStart=System.currentTimeMillis();
        double dist=Float.MAX_VALUE;
        Chunk nearestChunk=null;
        for (FastSet.Record n=_chunkUpdateNormal.head(), end=_chunkUpdateNormal.tail(); (n=n.getNext()) != end; ) {
          Chunk c=_chunkUpdateNormal.valueOf(n);
          double tDist=c.calcDistanceToPlayer();
          if (tDist <= dist) {
            dist=tDist;
            nearestChunk=c;
          }
        }
        if (nearestChunk != null) {
          processChunk(nearestChunk);
          _statUpdateDuration+=System.currentTimeMillis() - timeStart;
          _statUpdateDuration/=2;
        }
        updateDaytime();
        evolveChunks();
        _visibleChunks=fetchVisibleChunks();
        FastList<Chunk> chunksToDelete=new FastList<Chunk>();
        for (FastSet.Record n=_chunkUpdateNormal.head(), end=_chunkUpdateNormal.tail(); (n=n.getNext()) != end; ) {
          Chunk c=_chunkUpdateNormal.valueOf(n);
          if (!_visibleChunks.contains(c)) {
            chunksToDelete.add(c);
          }
        }
        for (FastList.Node<Chunk> n=chunksToDelete.head(), end=chunksToDelete.tail(); (n=n.getNext()) != end; ) {
          _chunkUpdateNormal.remove(n.getValue());
        }
      }
    }
  }
);
}
