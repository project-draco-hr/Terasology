{
  this._player=p;
  _rand=new FastRandom(seed.hashCode());
  _chunks=new Chunk[(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.x][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.y][(int)Configuration.VIEWING_DISTANCE_IN_CHUNKS.z];
  _generatorTerrain=new GeneratorTerrain(seed);
  _generatorForest=new GeneratorForest(seed);
  for (int x=0; x < Configuration.VIEWING_DISTANCE_IN_CHUNKS.x; x++) {
    for (int z=0; z < Configuration.VIEWING_DISTANCE_IN_CHUNKS.z; z++) {
      Chunk c=loadOrCreateChunk(x,z);
      _chunks[x][0][z]=c;
      queueChunkForUpdate(c);
    }
  }
  _player.resetPlayer();
  _updateThread=new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        long timeStart=System.currentTimeMillis();
        timeStart=System.currentTimeMillis();
        Object[] chunks=null;
        chunks=_chunkUpdateNormal.toArray();
        double dist=Float.MAX_VALUE;
        int index=-1;
        for (int i=0; i < chunks.length; i++) {
          Chunk c=(Chunk)chunks[i];
          double tDist=c.calcDistanceToPlayer();
          if (tDist <= dist) {
            dist=tDist;
            index=i;
          }
        }
        if (index >= 0) {
          Chunk c=(Chunk)chunks[index];
          processChunk(c);
          _chunkUpdateNormal.remove(c);
        }
        updateInfWorld();
        updateDaytime();
        _statUpdateDuration+=System.currentTimeMillis() - timeStart;
        _statUpdateDuration/=2;
      }
    }
  }
);
}
