{
  statDirtyChunks=0;
  statVisibleChunks=0;
  statIgnoredPhases=0;
  for (int i=0; i < chunksInProximity.size(); i++) {
    Chunk c=chunksInProximity.get(i);
    ChunkMesh[] mesh=c.getMesh();
    if (isChunkVisible(c) && isChunkValidForRender(c)) {
      if (triangleCount(mesh,ChunkMesh.RENDER_PHASE.OPAQUE) > 0)       renderQueueChunksOpaque.add(c);
 else       statIgnoredPhases++;
      if (triangleCount(mesh,ChunkMesh.RENDER_PHASE.REFRACTIVE) > 0)       renderQueueChunksSortedWater.add(c);
 else       statIgnoredPhases++;
      if (triangleCount(mesh,ChunkMesh.RENDER_PHASE.ALPHA_REJECT) > 0 && i < MAX_BILLBOARD_CHUNKS)       renderQueueChunksSortedBillboards.add(c);
 else       statIgnoredPhases++;
      if (i < MAX_ANIMATED_CHUNKS)       c.setAnimated(true);
 else       c.setAnimated(false);
      if (c.getPendingMesh() != null) {
        for (int j=0; j < c.getPendingMesh().length; j++) {
          c.getPendingMesh()[j].generateVBOs();
        }
        if (c.getMesh() != null) {
          for (int j=0; j < c.getMesh().length; j++) {
            c.getMesh()[j].dispose();
          }
        }
        c.setMesh(c.getPendingMesh());
        c.setPendingMesh(null);
      }
      if ((c.isDirty() || c.getMesh() == null) && isChunkValidForRender(c)) {
        statDirtyChunks++;
        chunkUpdateManager.queueChunkUpdate(c,ChunkUpdateManager.UPDATE_TYPE.DEFAULT);
      }
      statVisibleChunks++;
    }
 else     if (i > config.getRendering().getMaxChunkVBOs()) {
      if (mesh != null) {
        for (        ChunkMesh m : mesh) {
          m.dispose();
        }
        c.setMesh(null);
      }
    }
  }
}
