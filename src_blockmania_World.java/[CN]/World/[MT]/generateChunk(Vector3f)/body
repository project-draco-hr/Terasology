{
  Vector3f chunkOrigin=new Vector3f(chunkPosition.x * Chunk.chunkDimensions.x,chunkPosition.y * Chunk.chunkDimensions.y,chunkPosition.z * Chunk.chunkDimensions.z);
  for (int x=(int)chunkOrigin.x; x < (int)chunkOrigin.x + Chunk.chunkDimensions.x; x++) {
    for (int z=(int)chunkOrigin.z; z < (int)chunkOrigin.z + Chunk.chunkDimensions.z; z++) {
      setBlock(new Vector3f(x,0,z),0x3,false);
    }
  }
  for (int x=(int)chunkOrigin.x; x < (int)chunkOrigin.x + Chunk.chunkDimensions.x; x++) {
    for (int z=(int)chunkOrigin.z; z < (int)chunkOrigin.z + Chunk.chunkDimensions.z; z++) {
      float height=calcTerrainElevation(x,z) + (calcTerrainRoughness(x,z) * calcTerrainDetail(x,z)) * 64 + 64;
      float y=height;
      while (y > 0) {
        if (getCaveDensityAt(x,y,z) < 0.25) {
          if (height == y) {
            setBlock(new Vector3f(x,y,z),0x1,false);
          }
 else {
            setBlock(new Vector3f(x,y,z),0x2,false);
          }
        }
        y--;
      }
      if (rand.nextFloat() < 150f / 100000f && height > 32) {
        generateTree(new Vector3f(x,height,z));
      }
      for (int i=32; i > 0; i--) {
        if (getBlock(new Vector3f(x,i,z)) == 0) {
          setBlock(new Vector3f(x,i,z),0x4,false);
        }
      }
    }
  }
  Chunk c=chunks[(int)chunkPosition.x][(int)chunkPosition.y][(int)chunkPosition.z];
  if (c != null) {
    c.markAsDirty();
  }
}
