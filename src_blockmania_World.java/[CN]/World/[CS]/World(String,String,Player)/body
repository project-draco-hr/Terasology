{
  this.player=p;
  rand=new Random(seed.hashCode());
  final World currentWorld=this;
  chunks=new Chunk[(int)Configuration.viewingDistanceInChunks.x][(int)Configuration.viewingDistanceInChunks.y][(int)Configuration.viewingDistanceInChunks.z];
  updateThread=new Thread(new Runnable(){
    @Override public void run(){
      long timeStart=System.currentTimeMillis();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,"Generating chunks. Please wait.");
      for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
        for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
          for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
            Chunk c=new Chunk(currentWorld,new Vector3f(x,y,z));
            chunks[x][y][z]=c;
          }
        }
      }
      setWorldGenerated(true);
      player.resetPlayer();
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,"Calculating sunlight. Please wait.");
      for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
        for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
          for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
            Chunk c=chunks[x][y][z];
            c.calcSunlight();
          }
        }
      }
      Logger.getLogger(this.getClass().getName()).log(Level.INFO,"World updated ({0}s).",(System.currentTimeMillis() - timeStart) / 1000d);
      for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
        for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
          for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
            Chunk c=chunks[x][y][z];
            c.generateVertexArray();
            if (!chunkUpdateQueueDL.contains(c)) {
              chunkUpdateQueueDL.add(c);
            }
          }
        }
      }
      while (true) {
        while (chunkUpdateQueue.size() > 0 && !disableChunkUpdates) {
          Chunk c=null;
synchronized (chunkUpdateQueue) {
            c=chunkUpdateQueue.getLast();
          }
          c.calcSunlight();
          c.generateVertexArray();
synchronized (chunkUpdateQueueDL) {
            if (!chunkUpdateQueueDL.contains(c)) {
              chunkUpdateQueueDL.add(c);
              chunkUpdateQueue.remove(c);
            }
          }
        }
        if (Helper.getInstance().getTime() - daytime > 20000) {
          if (chunkUpdateQueue.size() == 0) {
            daylight-=0.1f;
            if (daylight < 0.3f) {
              daylight=0.8f;
            }
            for (int x=0; x < Configuration.viewingDistanceInChunks.x; x++) {
              for (int y=0; y < Configuration.viewingDistanceInChunks.y; y++) {
                for (int z=0; z < Configuration.viewingDistanceInChunks.z; z++) {
                  Chunk c=chunks[x][y][z];
synchronized (chunkUpdateQueue) {
                    if (!chunkUpdateQueue.contains(c)) {
                      chunkUpdateQueue.add(c);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
);
}
