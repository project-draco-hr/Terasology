{
  if (state.getClimbDirection() == null) {
    return;
  }
  Quat4f rotation=new Quat4f();
  Vector3f tmp;
  Side climbSide=state.getClimbDirection();
  Vector3i climbDir3i=climbSide.getVector3i();
  Vector3f climbDir3f=climbDir3i.toVector3f();
  QuaternionUtil.setEuler(rotation,TeraMath.DEG_TO_RAD * state.getYaw(),0,0);
  tmp=new Vector3f(0.0f,0.0f,-1.0f);
  QuaternionUtil.quatRotate(rotation,tmp,tmp);
  float angleToClimbDirection=tmp.angle(climbDir3f);
  boolean clearMovementToDirection=!state.isGrounded();
  if (angleToClimbDirection < Math.PI / 4.0 || Math.abs(input.getPitch()) > 60f) {
    float pitchAmount=state.isGrounded() ? 45f : 90f;
    float pitch=input.getPitch() > 30f ? pitchAmount : -pitchAmount;
    QuaternionUtil.setEuler(rotation,TeraMath.DEG_TO_RAD * state.getYaw(),TeraMath.DEG_TO_RAD * pitch,0);
    QuaternionUtil.quatRotate(rotation,desiredVelocity,desiredVelocity);
  }
 else   if (angleToClimbDirection < Math.PI * 3.0 / 4.0) {
    float pitchAmount=state.isGrounded() ? 45f : 90f;
    tmp=new Vector3f();
    QuaternionUtil.quatRotate(rotation,climbDir3f,tmp);
    float leftOrRight=tmp.x;
    float plusOrMinus=(leftOrRight < 0f ? -1.0f : 1.0f) * (climbDir3i.x != 0 ? -1.0f : 1.0f);
    QuaternionUtil.setEuler(rotation,TeraMath.DEG_TO_RAD * input.getYaw(),0f,TeraMath.DEG_TO_RAD * pitchAmount * plusOrMinus);
    QuaternionUtil.quatRotate(rotation,desiredVelocity,desiredVelocity);
  }
 else {
    QuaternionUtil.setEuler(rotation,TeraMath.DEG_TO_RAD * state.getYaw(),0,0);
    QuaternionUtil.quatRotate(rotation,desiredVelocity,desiredVelocity);
    clearMovementToDirection=false;
  }
  if (clearMovementToDirection) {
    if (climbDir3i.x != 0) {
      desiredVelocity.x=0f;
    }
    if (climbDir3i.z != 0) {
      desiredVelocity.z=0f;
    }
  }
}
