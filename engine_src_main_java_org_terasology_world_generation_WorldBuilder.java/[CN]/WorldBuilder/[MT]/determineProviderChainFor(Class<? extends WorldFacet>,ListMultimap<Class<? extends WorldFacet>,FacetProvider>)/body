{
  if (result.containsKey(facet)) {
    return;
  }
  if (!facetCalculationInProgress.add(facet)) {
    throw new RuntimeException("Circular dependency detected when calculating facet provider ordering for " + facet);
  }
  Set<FacetProvider> orderedProviders=Sets.newLinkedHashSet();
  FacetProvider producer=null;
  for (  FacetProvider provider : providersList) {
    if (producesFacet(provider,facet)) {
      if (producer != null) {
        logger.warn("Facet already produced by {} and overwritten by {}",producer,provider);
      }
      for (      Facet requirement : requiredFacets(provider)) {
        determineProviderChainFor(requirement.value(),result);
        orderedProviders.addAll(result.get(requirement.value()));
      }
      for (      Facet updated : updatedFacets(provider)) {
        determineProviderChainFor(updated.value(),result);
        orderedProviders.addAll(result.get(updated.value()));
      }
      orderedProviders.add(provider);
      producer=provider;
    }
  }
  if (producer == null) {
    logger.warn("No facet provider found that produces {}",facet);
  }
  for (  FacetProvider provider : providersList) {
    if (updatesFacet(provider,facet)) {
      for (      Facet requirement : requiredFacets(provider)) {
        determineProviderChainFor(requirement.value(),result);
        orderedProviders.addAll(result.get(requirement.value()));
      }
      for (      Facet updated : updatedFacets(provider)) {
        for (        FacetProvider fp : providersList) {
          if (producesFacet(fp,updated.value())) {
            orderedProviders.add(fp);
          }
        }
      }
      orderedProviders.add(provider);
    }
  }
  result.putAll(facet,orderedProviders);
  facetCalculationInProgress.remove(facet);
}
