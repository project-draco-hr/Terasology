{
  Region3i edgeRegion=TeraMath.getEdgeRegion(Region3i.createFromMinAndSize(Vector3i.zero(),ChunkConstants.CHUNK_SIZE),side);
  int edgeSize=edgeRegion.size().x * edgeRegion.size().y * edgeRegion.size().z;
  int[] depth=new int[edgeSize];
  Vector3i adjPos=new Vector3i();
  for (  Vector3i pos : edgeRegion) {
    int depthIndex=getIndexFor(pos,side,edgeRegion);
    adjPos.set(pos);
    adjPos.add(chunkEdgeDeltas.get(side));
    Block lastBlock=chunk.getBlock(pos);
    byte expectedValue=rules.propagateValue(rules.getValue(chunk,pos),side,lastBlock);
    int depthCounter=0;
    while (expectedValue > 0 && rules.canSpreadOutOf(lastBlock,side)) {
      Block currentBlock=adjChunk.getBlock(adjPos);
      if (rules.canSpreadInto(currentBlock,side.reverse()) && expectedValue > rules.getValue(adjChunk,adjPos)) {
        lastBlock=currentBlock;
        rules.setValue(adjChunk,adjPos,expectedValue);
        adjPos.add(side.getVector3i());
        depthCounter++;
        expectedValue=rules.propagateValue(expectedValue,side,lastBlock);
      }
 else {
        break;
      }
    }
    depth[depthIndex]=depthCounter;
  }
  for (  Vector3i pos : edgeRegion) {
    int depthIndex=getIndexFor(pos,side,edgeRegion);
    int adjacentDepth=depth[depthIndex];
    for (    Side adj : side.tangents()) {
      adjPos.set(pos);
      adjPos.add(adj.getVector3i());
      if (!ChunkConstants.CHUNK_REGION.encompasses(adjPos)) {
        adjacentDepth=0;
        break;
      }
 else {
        adjacentDepth=Math.min(adjacentDepth,depth[getIndexFor(adjPos,side,edgeRegion)]);
      }
    }
    for (int i=adjacentDepth; i < depth[depthIndex] - 1; ++i) {
      adjPos.set(side.getVector3i());
      adjPos.mult(i + 1);
      adjPos.add(pos);
      adjPos.add(chunkEdgeDeltas.get(side));
      if (!ChunkConstants.CHUNK_REGION.encompasses(adjPos)) {
        break;
      }
      byte value=rules.getValue(adjChunk,adjPos);
      if (value > 1) {
        queueSpreadValue(adjChunk.getBlockWorldPos(adjPos),value);
      }
    }
  }
}
