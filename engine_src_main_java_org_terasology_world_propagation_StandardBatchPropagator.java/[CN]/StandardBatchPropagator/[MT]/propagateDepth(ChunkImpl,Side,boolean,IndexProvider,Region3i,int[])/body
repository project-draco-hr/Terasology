{
  Vector3i adjPos=new Vector3i();
  int[] adjDepth=new int[depths.length];
  int dimA=(side == Side.LEFT || side == Side.RIGHT) ? ChunkConstants.SIZE_Y : ChunkConstants.SIZE_X;
  int dimB=(side == Side.FRONT || side == Side.BACK) ? ChunkConstants.SIZE_Y : ChunkConstants.SIZE_Z;
  System.arraycopy(depths,0,adjDepth,0,depths.length);
  adjDepth[0]=Math.min(depths[1],depths[dimA]);
  for (int x=1; x < dimA - 1; ++x) {
    adjDepth[x]=Math.min(depths[x - 1],Math.min(depths[x + 1],depths[x + dimA]));
  }
  adjDepth[dimA - 1]=Math.min(depths[2 * dimA - 1],depths[dimA - 2]);
  for (int y=1; y < dimB - 1; ++y) {
    adjDepth[y * dimA]=Math.min(depths[dimA * (y - 1)],Math.min(depths[dimA * (y + 1)],depths[1 + dimA * y]));
    for (int x=1; x < dimA - 1; ++x) {
      adjDepth[x + y * dimA]=Math.min(Math.min(depths[x + (y - 1) * dimA],depths[x + (y + 1) * dimA]),Math.min(depths[x + 1 + y * dimA],depths[x - 1 + y * dimA]));
    }
    adjDepth[dimA - 1 + y * dimA]=Math.min(depths[dimA - 1 + dimA * (y - 1)],Math.min(depths[dimA - 1 + dimA * (y + 1)],depths[dimA - 2 + dimA * y]));
  }
  adjDepth[dimA * (dimB - 1)]=Math.min(depths[1 + dimA * (dimB - 1)],depths[dimA * (dimB - 2)]);
  for (int x=1; x < dimA - 1; ++x) {
    adjDepth[x + dimA * (dimB - 1)]=Math.min(depths[x - 1 + dimA * (dimB - 1)],Math.min(depths[x + 1 + dimA * (dimB - 1)],depths[x + dimA * (dimB - 2)]));
  }
  adjDepth[dimA - 1 + dimA * (dimB - 1)]=Math.min(depths[dimA - 2 + dimA * (dimB - 1)],depths[dimA - 1 + dimA * (dimB - 2)]);
  if (propagateExternal) {
    for (int y=0; y < dimB; ++y) {
      adjDepth[y * dimA]=0;
      adjDepth[dimA - 1 + y * dimA]=0;
    }
    for (int x=0; x < dimA; ++x) {
      adjDepth[x]=0;
      adjDepth[x + dimA * (dimB - 1)]=0;
    }
  }
  for (  Vector3i pos : edgeRegion) {
    int depthIndex=indexProvider.getIndexFor(pos);
    int adjacentDepth=adjDepth[depthIndex];
    for (int i=adjacentDepth; i < depths[depthIndex] - 1; ++i) {
      adjPos.set(side.getVector3i());
      adjPos.mult(i + 1);
      adjPos.add(pos);
      adjPos.add(chunkEdgeDeltas.get(side));
      byte value=rules.getValue(adjChunk,adjPos);
      if (value > 1) {
        queueSpreadValue(adjChunk.getBlockWorldPos(adjPos),value);
      }
    }
  }
}
