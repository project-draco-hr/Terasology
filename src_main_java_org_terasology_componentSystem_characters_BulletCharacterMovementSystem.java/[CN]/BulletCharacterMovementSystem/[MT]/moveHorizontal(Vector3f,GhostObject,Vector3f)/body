{
  float remainingFraction=1.0f;
  Vector3f normalizedDir=Vector3fUtil.safeNormalize(horizMove,new Vector3f());
  Vector3f targetPos=new Vector3f(position);
  targetPos.add(horizMove);
  int iteration=0;
  while (remainingFraction >= 0.01f && iteration < 10) {
    SweepCallback callback=sweep(position,targetPos,collider,iteration++ * 0.005f);
    remainingFraction-=callback.closestHitFraction;
    if (callback.hasHit()) {
      Vector3f actualMove=new Vector3f();
      actualMove.sub(targetPos,position);
      actualMove.scale(Math.max(0,callback.closestHitFraction));
      position.add(actualMove);
      extractResidualMovement(callback.hitNormalWorld,targetPos,position);
      Vector3f currentDir=new Vector3f();
      currentDir.sub(targetPos,position);
      float sqrDist=currentDir.lengthSquared();
      if (sqrDist > BulletGlobals.SIMD_EPSILON) {
        currentDir.normalize();
        if (currentDir.dot(normalizedDir) <= 0.0f) {
          break;
        }
      }
 else {
        break;
      }
    }
 else {
      position.set(targetPos);
    }
  }
}
