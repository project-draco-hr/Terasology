{
  tick+=delta * 1000;
  if (tick - lastTick < timeBetweenSpawns) {
    return;
  }
  lastTick=tick;
  int maxMobs=entityManager.getComponentCount(SpawnerComponent.class) * maxMobsPerSpawner + maxMobsPerSpawner;
  int currentMobs=entityManager.getComponentCount(SimpleAIComponent.class);
  if (currentMobs >= maxMobs) {
    logger.info("Too many mobs! Returning early");
    return;
  }
  for (  EntityRef entity : entityManager.iteratorEntities(SpawnerComponent.class,BlockComponent.class)) {
    logger.info("Found a spawner: {}",entity);
    SpawnerComponent spawnComp=entity.getComponent(SpawnerComponent.class);
    int spawnTypes=spawnComp.types.size();
    if (spawnTypes == 0) {
      logger.warn("Spawner has no types, sad - stopping this loop iteration early :-(");
      continue;
    }
    BlockComponent blockComp=entity.getComponent(BlockComponent.class);
    if (currentMobs < maxMobs) {
      Vector3f pos=blockComp.getPosition().toVector3f();
      logger.info("Going to spawn something at {}",pos);
      String chosenSpawnerType=spawnComp.types.get(random.randomIntAbs(spawnComp.types.size()));
      Set randomType=typeLists.get(chosenSpawnerType);
      if (randomType.size() == 0) {
        logger.warn("That type wasn't found, sad :-( Won't spawn anything this time");
        return;
      }
      int anotherRandomIndex=random.randomIntAbs(randomType.size());
      Object[] randomPrefabs=randomType.toArray();
      Prefab chosenPrefab=(Prefab)randomPrefabs[anotherRandomIndex];
      logger.info("Picked index {} of types {} which is a {}",anotherRandomIndex,chosenSpawnerType,chosenPrefab);
      factory.generateGelatinousCube(pos,chosenPrefab);
      currentMobs++;
    }
  }
}
