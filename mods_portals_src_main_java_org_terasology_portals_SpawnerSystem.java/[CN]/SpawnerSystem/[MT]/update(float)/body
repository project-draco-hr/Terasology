{
  tick+=delta * 1000;
  if (tick - classLastTick < 1000) {
    return;
  }
  classLastTick=tick;
  PerformanceMonitor.startActivity("Spawn creatures");
  try {
    logger.info("Count of entities with a SpawnerComponent: {}",entityManager.getComponentCount(SpawnerComponent.class));
    for (    EntityRef entity : entityManager.iteratorEntities(SpawnerComponent.class)) {
      SpawnerComponent spawnComp=entity.getComponent(SpawnerComponent.class);
      if (spawnComp.lastTick > tick) {
        spawnComp.lastTick=tick;
      }
      if (tick - spawnComp.lastTick < spawnComp.timeBetweenSpawns) {
        return;
      }
      spawnComp.lastTick=tick;
      if (spawnComp.maxMobsPerSpawner > 0) {
        int maxMobs=entityManager.getComponentCount(SpawnerComponent.class) * spawnComp.maxMobsPerSpawner;
        int currentMobs=entityManager.getComponentCount(SimpleAIComponent.class) + entityManager.getComponentCount(HierarchicalAIComponent.class);
        logger.info("Mob count: {}/{}",currentMobs,maxMobs);
        if (currentMobs >= maxMobs) {
          logger.info("Too many mobs! Returning early");
          return;
        }
      }
      int spawnTypes=spawnComp.types.size();
      if (spawnTypes == 0) {
        logger.warn("Spawner has no types, sad - stopping this loop iteration early :-(");
        continue;
      }
      Vector3f originPos=new Vector3f();
      if (entity.hasComponent(BlockComponent.class)) {
        BlockComponent blockComp=entity.getComponent(BlockComponent.class);
        originPos=blockComp.getPosition().toVector3f();
        if (spawnComp.needsPlayer) {
          LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
          if (localPlayer != null) {
            Vector3f dist=new Vector3f(originPos);
            dist.sub(localPlayer.getPosition());
            double distanceToPlayer=dist.lengthSquared();
            if (distanceToPlayer > spawnComp.playerNeedRange) {
              logger.info("Spawner {} too far from player {}<{}",entity.getId(),distanceToPlayer,spawnComp.playerNeedRange);
              continue;
            }
          }
        }
      }
 else       if (entity.hasComponent(LocalPlayerComponent.class)) {
        LocalPlayerComponent lpc=entity.getComponent(LocalPlayerComponent.class);
        if (lpc.isDead) {
          return;
        }
        LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
        originPos=localPlayer.getPosition();
        logger.info("Player position: {}, {}, {}",originPos.x,originPos.y,originPos.z);
      }
      Vector3f spawnPos=originPos;
      if (spawnComp.rangedSpawning) {
        spawnPos=new Vector3f(originPos.x + random.randomFloat() * spawnComp.range,originPos.y,originPos.z + random.randomFloat() * spawnComp.range);
        if (spawnComp.minDistance != 0) {
          Vector3f dist=new Vector3f(spawnPos);
          dist.sub(originPos);
          if (spawnComp.minDistance > dist.lengthSquared()) {
            return;
          }
        }
        int offset=1;
        while (offset < 30) {
          if (worldProvider.getBlock(new Vector3f(spawnPos.x,spawnPos.y + offset,spawnPos.z)).isPenetrable() && validateSpawnPos(new Vector3f(spawnPos.x,spawnPos.y + offset,spawnPos.z),1,1,1)) {
            break;
          }
 else           if (worldProvider.getBlock(new Vector3f(spawnPos.x,spawnPos.y - offset,spawnPos.z)).isPenetrable() && validateSpawnPos(new Vector3f(spawnPos.x,spawnPos.y - offset,spawnPos.z),1,1,1)) {
            offset*=-1;
            break;
          }
          offset++;
        }
        if (offset == 30) {
          logger.info("Failed to find an open position to spawn at, sad");
          return;
        }
 else {
          spawnPos=new Vector3f(spawnPos.x,spawnPos.y + offset,spawnPos.z);
          logger.info("Found a valid spawn position that can fit the Spawnable! {}",spawnPos);
        }
      }
      String chosenSpawnerType=spawnComp.types.get(random.randomIntAbs(spawnComp.types.size()));
      Set randomType=typeLists.get(chosenSpawnerType);
      logger.info("Picked random type {} which returned {} prefabs",chosenSpawnerType,randomType.size());
      if (randomType.size() == 0) {
        logger.warn("Type {} wasn't found, sad :-( Won't spawn anything this time",chosenSpawnerType);
        return;
      }
      int anotherRandomIndex=random.randomIntAbs(randomType.size());
      Object[] randomPrefabs=randomType.toArray();
      Prefab chosenPrefab=(Prefab)randomPrefabs[anotherRandomIndex];
      logger.info("Picked index {} of types {} which is a {}, to spawn at {}",anotherRandomIndex,chosenSpawnerType,chosenPrefab,spawnPos);
      factory.generate(spawnPos,chosenPrefab);
    }
    for (int i=0; i < 1000000; i++) {
      int fun=2 + 6;
    }
  }
  finally {
    PerformanceMonitor.endActivity();
  }
}
