{
  PerformanceMonitor.startActivity("GenerateMesh");
  ChunkMesh mesh=new ChunkMesh(bufferPool);
  Vector3f chunkOffset=new Vector3f(chunkPos.x * ChunkConstants.SIZE_X,chunkPos.y * ChunkConstants.SIZE_Y,chunkPos.z * ChunkConstants.SIZE_Z);
  final Stopwatch watch=Stopwatch.createStarted();
  Region region=generatingChunkProvider.getWorldData(chunkView.getWorldRegion());
  SurfaceTemperatureFacet surfaceTemperatureFacet=null;
  SurfaceHumidityFacet surfaceHumidityFacet=null;
  if (region != null) {
    surfaceTemperatureFacet=region.getFacet(SurfaceTemperatureFacet.class);
    surfaceHumidityFacet=region.getFacet(SurfaceHumidityFacet.class);
  }
  for (int x=0; x < ChunkConstants.SIZE_X; x++) {
    for (int z=0; z < ChunkConstants.SIZE_Z; z++) {
      Vector3f worldPos=new Vector3f(chunkOffset.x + x,chunkOffset.y,chunkOffset.z + z);
      float biomeTemp=0.5f;
      if (surfaceTemperatureFacet != null) {
        biomeTemp=surfaceHumidityFacet.get(x,z);
      }
      float biomeHumidity=0.5f;
      if (surfaceHumidityFacet != null) {
        biomeHumidity=surfaceHumidityFacet.get(x,z);
      }
      for (int y=verticalOffset; y < verticalOffset + meshHeight; y++) {
        Block block=chunkView.getBlock(x,y,z);
        if (block != null && !block.isInvisible()) {
          generateBlockVertices(chunkView,mesh,x,y,z,biomeTemp,biomeHumidity);
        }
      }
    }
  }
  watch.stop();
  mesh.setTimeToGenerateBlockVertices((int)watch.elapsed(TimeUnit.MILLISECONDS));
  watch.reset().start();
  generateOptimizedBuffers(chunkView,mesh);
  watch.stop();
  mesh.setTimeToGenerateOptimizedBuffers((int)watch.elapsed(TimeUnit.MILLISECONDS));
  statVertexArrayUpdateCount++;
  PerformanceMonitor.endActivity();
  return mesh;
}
