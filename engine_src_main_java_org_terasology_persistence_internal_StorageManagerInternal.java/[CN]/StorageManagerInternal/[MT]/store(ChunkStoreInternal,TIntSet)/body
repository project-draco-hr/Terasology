{
  if (externalRefs.size() > 0) {
    StoreMetadata metadata=new StoreMetadata(new ChunkStoreId(chunkStore.getChunkPosition()),externalRefs);
    indexStoreMetadata(metadata);
  }
  pendingProcessingChunkStore.put(chunkStore.getChunkPosition(),chunkStore);
  try {
    storageTaskMaster.put(new AbstractTask(){
      @Override public String getName(){
        return "Compress chunk";
      }
      @Override public void run(){
        EntityData.ChunkStore store=chunkStore.getStore();
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        try (GZIPOutputStream gzipOut=new GZIPOutputStream(baos)){
          store.writeTo(gzipOut);
        }
 catch (        IOException e) {
          logger.error("Failed to compress chunk {} for storage.",chunkStore.getChunkPosition(),e);
        }
        byte[] b=baos.toByteArray();
        compressedChunkStore.put(chunkStore.getChunkPosition(),b);
        pendingProcessingChunkStore.remove(chunkStore.getChunkPosition());
      }
    }
);
  }
 catch (  InterruptedException e) {
    logger.error("Interrupted while submitting chunk for storage",e);
  }
}
