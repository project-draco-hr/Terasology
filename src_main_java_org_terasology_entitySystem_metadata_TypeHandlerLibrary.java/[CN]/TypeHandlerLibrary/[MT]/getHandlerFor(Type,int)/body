{
  Class<?> typeClass=ReflectionUtil.getClassOfType(type);
  if (typeClass == null) {
    logger.error("Cannot obtain class for type {}",type);
    return null;
  }
  if (Enum.class.isAssignableFrom(typeClass)) {
    return new EnumTypeHandler(typeClass);
  }
 else   if (List.class.isAssignableFrom(typeClass)) {
    Type parameter=ReflectionUtil.getTypeParameter(type,0);
    if (parameter != null) {
      TypeHandler innerHandler=getHandlerFor(parameter,depth);
      if (innerHandler != null) {
        return new ListTypeHandler(innerHandler);
      }
    }
    logger.error("List field is not parameterized, or holds unsupported type");
    return null;
  }
 else   if (Set.class.isAssignableFrom(typeClass)) {
    Type parameter=ReflectionUtil.getTypeParameter(type,0);
    if (parameter != null) {
      TypeHandler innerHandler=getHandlerFor(parameter,depth);
      if (innerHandler != null) {
        return new SetTypeHandler(innerHandler);
      }
    }
    logger.error("Set field is not parameterized, or holds unsupported type");
    return null;
  }
 else   if (Map.class.isAssignableFrom(typeClass)) {
    Type keyParameter=ReflectionUtil.getTypeParameter(type,0);
    Type contentsParameter=ReflectionUtil.getTypeParameter(type,1);
    if (keyParameter != null && contentsParameter != null && String.class == keyParameter) {
      TypeHandler valueHandler=getHandlerFor(contentsParameter,depth);
      if (valueHandler != null) {
        return new StringMapTypeHandler(valueHandler);
      }
    }
    logger.error("Map field is not parameterized, does not have a String key, or holds unsupported values");
  }
 else   if (typeHandlers.containsKey(typeClass)) {
    return typeHandlers.get(typeClass);
  }
 else   if (depth <= MAX_SERIALIZATION_DEPTH && !Modifier.isAbstract(typeClass.getModifiers()) && !typeClass.isLocalClass() && !(typeClass.isMemberClass() && !Modifier.isStatic(typeClass.getModifiers()))) {
    if (typeClass.getAnnotation(MappedContainer.class) == null) {
      logger.error("Unable to register field of type {}: not a supported type or MappedContainer",typeClass.getSimpleName());
      return null;
    }
    try {
      typeClass.getConstructor();
    }
 catch (    NoSuchMethodException e) {
      logger.error("Unable to register field of type {}: no publicly accessible default constructor",typeClass.getSimpleName());
      return null;
    }
    MappedContainerTypeHandler mappedHandler=new MappedContainerTypeHandler(typeClass);
    for (    Field field : typeClass.getDeclaredFields()) {
      if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers()))       continue;
      field.setAccessible(true);
      TypeHandler handler=getHandlerFor(field.getGenericType(),depth + 1);
      if (handler == null) {
        logger.error("Unsupported field type in component type {}, {} : {}",typeClass.getSimpleName(),field.getName(),field.getGenericType());
      }
 else {
        mappedHandler.addField(new FieldMetadata(field,handler,false));
      }
    }
    return mappedHandler;
  }
  return null;
}
