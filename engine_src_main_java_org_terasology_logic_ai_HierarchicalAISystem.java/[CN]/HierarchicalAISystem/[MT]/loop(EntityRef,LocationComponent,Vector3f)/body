{
  HierarchicalAIComponent ai=entity.getComponent(HierarchicalAIComponent.class);
  long tempTime=CoreRegistry.get(Time.class).getGameTimeInMs();
  long lastAttack=0;
  if (tempTime - ai.lastProgressedUpdateAt < ai.updateFrequency) {
    ai.lastProgressedUpdateAt=CoreRegistry.get(Time.class).getGameTimeInMs();
    return;
  }
  long directionChangeTime=ai.moveUpdateTime;
  long moveChangeTime=ai.moveUpdateTime;
  long idleChangeTime=ai.idlingUpdateTime;
  long dangerChangeTime=ai.dangerUpdateTime;
  Vector3f drive=new Vector3f();
  LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
  if (localPlayer != null) {
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(localPlayer.getPosition());
    double distanceToPlayer=dist.lengthSquared();
    ai.inDanger=false;
    if (ai.dieIfPlayerFar && distanceToPlayer > ai.dieDistance) {
      entity.destroy();
    }
    if (ai.aggressive) {
      if (distanceToPlayer <= ai.attackDistance) {
        if (tempTime - lastAttack > ai.damageFrequency) {
          localPlayer.getCharacterEntity().send(new DoDamageEvent(ai.damage,EngineDamageTypes.PHYSICAL.get(),entity));
          lastAttack=CoreRegistry.get(Time.class).getGameTimeInMs();
        }
      }
    }
    if (tempTime - ai.lastChangeOfDangerAt > dangerChangeTime) {
      dangerChangeTime=(long)(ai.dangerUpdateTime * random.nextDouble() * ai.hectic);
      if (ai.hunter) {
        if (distanceToPlayer > ai.playerdistance && distanceToPlayer < ai.playerSense) {
          Vector3f tempTarget=localPlayer.getPosition();
          if (ai.forgiving != 0) {
            ai.movementTarget.set(new Vector3f(tempTarget.x + random.nextFloat(-ai.forgiving,ai.forgiving),tempTarget.y + random.nextFloat(-ai.forgiving,ai.forgiving),tempTarget.z + random.nextFloat(-ai.forgiving,ai.forgiving)));
          }
 else {
            ai.movementTarget.set(tempTarget);
          }
          ai.inDanger=true;
          entity.saveComponent(ai);
        }
      }
      if (ai.wild) {
        if (distanceToPlayer > ai.panicDistance && distanceToPlayer < ai.runDistance) {
          Vector3f tempTarget=localPlayer.getPosition();
          if (ai.forgiving != 0) {
            ai.movementTarget.set(new Vector3f(-tempTarget.x + random.nextFloat(-ai.forgiving,ai.forgiving),-tempTarget.y + random.nextFloat(-ai.forgiving,ai.forgiving),-tempTarget.z + random.nextFloat(-ai.forgiving,ai.forgiving)));
          }
 else {
            ai.movementTarget.set(new Vector3f(tempTarget.x * -1,tempTarget.y * -1,tempTarget.z * -1));
          }
          entity.saveComponent(ai);
          ai.inDanger=true;
        }
      }
      ai.lastChangeOfDangerAt=CoreRegistry.get(Time.class).getGameTimeInMs();
    }
  }
  if (!ai.inDanger) {
    if (foodInFront()) {
      return;
    }
    if (idling) {
      if (tempTime - ai.lastChangeOfidlingtAt > idleChangeTime) {
        idleChangeTime=(long)(ai.idlingUpdateTime * random.nextDouble() * ai.hectic);
        idling=false;
        ai.lastChangeOfidlingtAt=CoreRegistry.get(Time.class).getGameTimeInMs();
      }
      entity.saveComponent(location);
      ai.lastProgressedUpdateAt=CoreRegistry.get(Time.class).getGameTimeInMs();
      return;
    }
    if (tempTime - ai.lastChangeOfMovementAt > moveChangeTime) {
      moveChangeTime=(long)(ai.moveUpdateTime * random.nextDouble() * ai.hectic);
      idling=true;
      entity.saveComponent(location);
      ai.lastChangeOfMovementAt=CoreRegistry.get(Time.class).getGameTimeInMs();
      ai.lastProgressedUpdateAt=CoreRegistry.get(Time.class).getGameTimeInMs();
      return;
    }
    if (tempTime - ai.lastChangeOfDirectionAt > directionChangeTime) {
      directionChangeTime=(long)(ai.moveUpdateTime * random.nextDouble() * ai.straightLined);
      if (ai.flying) {
        float targetY=0;
        do {
          targetY=worldPos.y + random.nextFloat(-100.0f,100.0f);
        }
 while (targetY > ai.maxAltitude);
        ai.movementTarget.set(worldPos.x + random.nextFloat(-500.0f,500.0f),targetY,worldPos.z + random.nextFloat(-500.0f,500.0f));
      }
 else {
        ai.movementTarget.set(worldPos.x + random.nextFloat(-500.0f,500.0f),worldPos.y,worldPos.z + random.nextFloat(-500.0f,500.0f));
      }
      ai.lastChangeOfDirectionAt=time.getGameTimeInMs();
      entity.saveComponent(ai);
    }
  }
  Vector3f targetDirection=new Vector3f();
  targetDirection.sub(ai.movementTarget,worldPos);
  targetDirection.normalize();
  drive.set(targetDirection);
  float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
  entity.send(new CharacterMoveInputEvent(0,0,yaw,drive,false,false));
  entity.saveComponent(location);
  ai.lastProgressedUpdateAt=CoreRegistry.get(Time.class).getGameTimeInMs();
}
