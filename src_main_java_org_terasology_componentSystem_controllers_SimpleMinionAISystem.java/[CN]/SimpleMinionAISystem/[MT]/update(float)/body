{
  for (  EntityRef entity : entityManager.iteratorEntities(SimpleMinionAIComponent.class,CharacterMovementComponent.class,LocationComponent.class,MinionComponent.class)) {
    LocationComponent location=entity.getComponent(LocationComponent.class);
    SimpleMinionAIComponent ai=entity.getComponent(SimpleMinionAIComponent.class);
    CharacterMovementComponent moveComp=entity.getComponent(CharacterMovementComponent.class);
    MinionComponent minioncomp=entity.getComponent(MinionComponent.class);
    Vector3f worldPos=location.getWorldPosition();
    moveComp.getDrive().set(0,0,0);
    LocalPlayer localPlayer=CoreRegistry.get(LocalPlayer.class);
    if (localPlayer != null) {
switch (minioncomp.minionBehaviour) {
case Follow:
{
          Vector3f dist=new Vector3f(worldPos);
          dist.sub(localPlayer.getPosition());
          double distanceToPlayer=dist.lengthSquared();
          if (distanceToPlayer > 8) {
            Vector3f target=localPlayer.getPosition();
            ai.movementTarget.set(target);
            ai.followingPlayer=true;
            entity.saveComponent(ai);
          }
          Vector3f targetDirection=new Vector3f();
          targetDirection.sub(ai.movementTarget,worldPos);
          if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
            targetDirection.normalize();
            moveComp.setDrive(targetDirection);
            float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
            AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
            location.getLocalRotation().set(axisAngle);
          }
 else {
            moveComp.getDrive().set(0,0,0);
          }
          entity.saveComponent(moveComp);
          entity.saveComponent(location);
          break;
        }
case Gather:
{
        List<Vector3f> targets=ai.gatherTargets;
        if (targets == null || targets.size() < 1)         break;
        Vector3f currentTarget=targets.get(0);
        Vector3f dist=new Vector3f(worldPos);
        dist.sub(currentTarget);
        double distanceToTarget=dist.lengthSquared();
        if (distanceToTarget < 4) {
          if (timer.getTimeInMs() - ai.lastAttacktime > 500) {
            ai.lastAttacktime=timer.getTimeInMs();
            boolean attacked=attack(entity,currentTarget);
            if (!attacked) {
              ai.gatherTargets.remove(currentTarget);
            }
          }
        }
        Vector3f targetDirection=new Vector3f();
        targetDirection.sub(currentTarget,worldPos);
        if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
          targetDirection.normalize();
          moveComp.setDrive(targetDirection);
          float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
          AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
          location.getLocalRotation().set(axisAngle);
        }
 else {
          moveComp.setDrive(new Vector3f());
        }
        entity.saveComponent(ai);
        entity.saveComponent(moveComp);
        entity.saveComponent(location);
        break;
      }
case Move:
{
      List<Vector3f> targets=ai.movementTargets;
      if (targets == null || targets.size() < 1)       break;
      Vector3f currentTarget=targets.get(0);
      Vector3f dist=new Vector3f(worldPos);
      dist.sub(currentTarget);
      double distanceToTarget=dist.length();
      if (distanceToTarget < 1.0d) {
        ai.movementTargets.remove(0);
        entity.saveComponent(ai);
        currentTarget=null;
        break;
      }
      Vector3f targetDirection=new Vector3f();
      targetDirection.sub(currentTarget,worldPos);
      if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
        targetDirection.normalize();
        moveComp.setDrive(targetDirection);
        float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
        AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
        location.getLocalRotation().set(axisAngle);
      }
 else {
        moveComp.setDrive(new Vector3f());
      }
      entity.saveComponent(moveComp);
      entity.saveComponent(location);
      break;
    }
case Patrol:
{
    List<Vector3f> targets=ai.patrolTargets;
    if (targets == null || targets.size() < 1)     break;
    int patrolCounter=ai.patrolCounter;
    Vector3f currentTarget=null;
    if (patrolCounter < targets.size()) {
      currentTarget=targets.get(patrolCounter);
    }
    if (currentTarget == null) {
      break;
    }
    Vector3f dist=new Vector3f(worldPos);
    dist.sub(currentTarget);
    double distanceToTarget=dist.length();
    if (distanceToTarget < 1.0d) {
      patrolCounter++;
      if (!(patrolCounter < targets.size()))       patrolCounter=0;
      ai.patrolCounter=patrolCounter;
      entity.saveComponent(ai);
      break;
    }
    Vector3f targetDirection=new Vector3f();
    targetDirection.sub(currentTarget,worldPos);
    if (targetDirection.x * targetDirection.x + targetDirection.z * targetDirection.z > 0.01f) {
      targetDirection.normalize();
      moveComp.setDrive(targetDirection);
      float yaw=(float)Math.atan2(targetDirection.x,targetDirection.z);
      AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
      location.getLocalRotation().set(axisAngle);
    }
 else {
      moveComp.setDrive(new Vector3f());
    }
    entity.saveComponent(moveComp);
    entity.saveComponent(location);
    break;
  }
case Test:
{
}
default :
{
break;
}
}
}
}
}
