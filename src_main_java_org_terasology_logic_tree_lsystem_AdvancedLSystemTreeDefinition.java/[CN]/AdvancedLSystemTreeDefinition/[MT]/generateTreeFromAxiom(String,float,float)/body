{
  Map<Vector3i,Block> treeInMemory=Maps.newHashMap();
  Stack<Vector3f> stackPosition=new Stack<>();
  Stack<Matrix4f> stackOrientation=new Stack<>();
  Vector3f position=new Vector3f(0,0,0);
  Matrix4f rotation=new Matrix4f();
  rotation.setIdentity();
  rotation.rotY(treeRotation);
  Callback callback=new Callback(treeInMemory,position,rotation);
  for (  AxionElement axion : parseAxions(currentAxion)) {
    Matrix4f tempRotation=new Matrix4f();
    tempRotation.setIdentity();
    char c=axion.key;
switch (c) {
case '[':
      stackOrientation.push(new Matrix4f(rotation));
    stackPosition.push(new Vector3f(position));
  break;
case ']':
rotation.set(stackOrientation.pop());
position.set(stackPosition.pop());
break;
case '&':
tempRotation.setIdentity();
tempRotation.rotX(angle + angleOffset);
rotation.mul(tempRotation);
break;
case '^':
tempRotation.setIdentity();
tempRotation.rotX(-angle - angleOffset);
rotation.mul(tempRotation);
break;
case '+':
tempRotation.setIdentity();
tempRotation.rotY((float)Math.toRadians(Integer.parseInt(axion.parameter)));
rotation.mul(tempRotation);
break;
case '-':
tempRotation.setIdentity();
tempRotation.rotY(-(float)Math.toRadians(Integer.parseInt(axion.parameter)));
rotation.mul(tempRotation);
break;
default :
AxionElementGeneration axionElementGeneration=blockMap.get(c);
if (axionElementGeneration != null) {
axionElementGeneration.generate(callback,position,rotation,axion.parameter);
}
}
}
return treeInMemory;
}
