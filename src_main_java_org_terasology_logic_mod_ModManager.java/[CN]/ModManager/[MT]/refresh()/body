{
  mods.clear();
  Gson gson=new Gson();
  File modPath=PathManager.getInstance().getModPath();
  for (  File modFile : modPath.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      return pathname.isDirectory();
    }
  }
)) {
    File modInfoFile=new File(modFile,"mod.txt");
    if (modInfoFile.exists()) {
      try {
        ModInfo modInfo=gson.fromJson(new FileReader(modInfoFile),ModInfo.class);
        if (!mods.containsKey(modInfo.getId())) {
          File assetLocation=new File(modFile,ASSETS_SUBDIRECTORY);
          AssetSource source;
          if (assetLocation.exists() && assetLocation.isDirectory()) {
            source=new DirectorySource(modInfo.getId(),assetLocation);
          }
 else {
            source=new NullSource(modInfo.getId());
          }
          Mod mod=new Mod(modFile,modInfo,source);
          mods.put(modInfo.getId(),mod);
          logger.info("Discovered mod: {} (hasCode = {})",modInfo.getDisplayName(),mod.isCodeMod());
        }
 else {
          logger.info("Discovered duplicate mod: {}, skipping",modInfo.getDisplayName());
        }
      }
 catch (      FileNotFoundException e) {
        logger.warn("Failed to load mod manifest for mod at {}",modFile,e);
      }
catch (      JsonIOException e) {
        logger.warn("Failed to load mod manifest for mod at {}",modFile,e);
      }
    }
  }
  for (  File modFile : modPath.listFiles(new FileFilter(){
    @Override public boolean accept(    File pathname){
      return pathname.isFile() && (pathname.getName().endsWith(".zip") || pathname.getName().endsWith(".jar"));
    }
  }
)) {
    try {
      ZipFile zipFile=new ZipFile(modFile);
      ZipEntry modInfoEntry=zipFile.getEntry("mod.txt");
      if (modInfoEntry != null) {
        try {
          ModInfo modInfo=gson.fromJson(new InputStreamReader(zipFile.getInputStream(modInfoEntry)),ModInfo.class);
          if (!mods.containsKey(modInfo.getId())) {
            Mod mod=new Mod(modFile,modInfo,new ArchiveSource(modInfo.getId(),modFile,ASSETS_SUBDIRECTORY));
            mods.put(modInfo.getId(),mod);
            logger.info("Discovered mod: {} (hasCode = {})",modInfo.getDisplayName(),mod.isCodeMod());
          }
 else {
            logger.info("Discovered duplicate mod: " + modInfo.getDisplayName() + ", skipping");
          }
        }
 catch (        FileNotFoundException e) {
          logger.warn("Failed to load mod manifest for mod at {}",modFile,e);
        }
catch (        JsonIOException e) {
          logger.warn("Failed to load mod manifest for mod at {}",modFile,e);
        }
      }
    }
 catch (    IOException e) {
      logger.error("Invalid mod file: {}",modFile,e);
    }
  }
  List<URL> urls=Lists.newArrayList();
  for (  Mod mod : getMods()) {
    if (mod.isCodeMod()) {
      urls.add(mod.getModClasspathUrl());
    }
  }
  allModClassLoader=new URLClassLoader(urls.toArray(new URL[urls.size()]),getClass().getClassLoader());
  for (  Mod mod : getMods()) {
    mod.setInactiveClassLoader(allModClassLoader);
  }
  activeModClassLoader=null;
  allReflections=null;
  for (  String activeModId : Config.getInstance().getActiveMods()) {
    Mod mod=mods.get(activeModId);
    if (mod != null) {
      mod.setEnabled(true);
    }
  }
}
