{
  TextCacheKey key=new TextCacheKey(text,font,region.width(),hAlign);
  usedText.add(key);
  Map<Material,Mesh> fontMesh=cachedText.get(key);
  List<String> lines=LineBuilder.getLines(font,text,region.width());
  Rect2i absoluteRegion=relativeToAbsolute(region);
  if (!state.cropRegion.overlaps(absoluteRegion)) {
    return;
  }
  if (fontMesh == null) {
    fontMesh=font.createTextMesh(lines,absoluteRegion.width(),hAlign);
    cachedText.put(key,fontMesh);
  }
  for (  Map.Entry<Material,Mesh> entry : fontMesh.entrySet()) {
    entry.getKey().bindTextures();
    if (shadowColor.a() != 0) {
      entry.getKey().setFloat2("offset",absoluteRegion.minX() + 1,absoluteRegion.minY() + 1);
      Vector4f shadowValues=shadowColor.toVector4f();
      shadowValues.w*=state.getAlpha();
      entry.getKey().setFloat4("color",shadowValues);
      entry.getKey().setFloat4("croppingBoundaries",state.cropRegion.minX(),state.cropRegion.maxX() + 1,state.cropRegion.minY(),state.cropRegion.maxY() + 1);
      entry.getValue().render();
    }
    entry.getKey().setFloat2("offset",absoluteRegion.minX(),absoluteRegion.minY());
    Vector4f colorValues=state.textColor.toVector4f();
    colorValues.w*=state.getAlpha();
    entry.getKey().setFloat4("color",colorValues);
    if (shadowColor.a() == 0) {
      entry.getKey().setFloat4("croppingBoundaries",state.cropRegion.minX(),state.cropRegion.maxX() + 1,state.cropRegion.minY(),state.cropRegion.maxY() + 1);
    }
    entry.getValue().render();
  }
}
