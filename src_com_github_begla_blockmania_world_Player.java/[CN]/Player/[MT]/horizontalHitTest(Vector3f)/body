{
  boolean result=false;
  FastList<BlockPosition> blockPositions=gatherAdjacentBlockPositions(origin);
  for (FastList.Node<BlockPosition> n=blockPositions.head(), end=blockPositions.tail(); (n=n.getNext()) != end; ) {
    byte blockType=_parent.getBlockAtPosition(VectorPool.getVector(n.getValue().x,n.getValue().y,n.getValue().z));
    AABB blockAABB=Block.AABBForBlockAt(n.getValue().x,n.getValue().y,n.getValue().z);
    if (!Block.getBlockForType(blockType).isPenetrable()) {
      if (getAABB().overlaps(blockAABB)) {
        result=true;
        Vector3f direction=VectorPool.getVector(_position.x,0f,_position.z);
        direction.x-=origin.x;
        direction.z-=origin.z;
        Vector3f blockPoi=blockAABB.closestPointOnAABBToPoint(origin);
        Vector3f playerPoi=generateAABBForPosition(origin).closestPointOnAABBToPoint(blockPoi);
        Vector3f planeNormal=blockAABB.normalForPlaneClosestToOrigin(blockPoi,origin,true,false,true);
        Vector3f slideVector=VectorPool.getVector(planeNormal.z,0,-planeNormal.x);
        Vector3f pushBack=VectorPool.getVector();
        Vector3f.sub(blockPoi,playerPoi,pushBack);
        double length=Vector3f.dot(slideVector,direction);
        Vector3f newPosition=VectorPool.getVector();
        newPosition.z=(float)(origin.z + pushBack.z * 0.2 + length * slideVector.z);
        newPosition.x=(float)(origin.x + pushBack.x * 0.2 + length * slideVector.x);
        newPosition.y=origin.y;
        _position.set(newPosition);
        VectorPool.putVector(newPosition);
        VectorPool.putVector(slideVector);
        VectorPool.putVector(direction);
      }
    }
  }
  return result;
}
