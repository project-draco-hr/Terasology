{
  int vertexCount=vertices.size() / VERTEX_SIZE;
  boolean hasTexCoord0=texCoord0 != null && texCoord0.size() / TEX_COORD_0_SIZE == vertexCount;
  boolean hasTexCoord1=texCoord1 != null && texCoord1.size() / TEX_COORD_1_SIZE == vertexCount;
  boolean hasNormals=normals != null && normals.size() / NORMAL_SIZE == vertexCount;
  boolean hasColors=colors != null && colors.size() / COLOR_SIZE == vertexCount;
  int vertSize=VERTEX_SIZE + (hasTexCoord0 ? TEX_COORD_0_SIZE : 0) + (hasTexCoord1 ? TEX_COORD_1_SIZE : 0)+ (hasNormals ? NORMAL_SIZE : 0)+ (hasColors ? COLOR_SIZE : 0);
  FloatBuffer vertexBuffer=createVertexBuffer(vertices,texCoord0,texCoord1,normals,colors,vertexCount,hasTexCoord0,hasTexCoord1,hasNormals,hasColors,vertSize);
  IntBuffer indexBuffer=BufferUtils.createIntBuffer(indices.size());
  TIntIterator iterator=indices.iterator();
  while (iterator.hasNext()) {
    indexBuffer.put(iterator.next());
  }
  indexBuffer.flip();
  Mesh mesh=new Mesh();
  mesh.vboVertexBuffer=VertexBufferObjectManager.getInstance().getVboId();
  mesh.vboIndexBuffer=VertexBufferObjectManager.getInstance().getVboId();
  mesh.indexCount=indices.size();
  mesh.aabb=calculateAABB(vertices,vertexCount);
  VertexBufferObjectManager.getInstance().bufferVboData(mesh.vboVertexBuffer,vertexBuffer,GL15.GL_STATIC_DRAW);
  VertexBufferObjectManager.getInstance().bufferVboElementData(mesh.vboIndexBuffer,indexBuffer,GL15.GL_STATIC_DRAW);
  mesh.stride=vertSize * 4;
  mesh.vertexOffset=0;
  int offset=VERTEX_SIZE;
  if (hasTexCoord0) {
    mesh.hasTexCoord0=hasTexCoord0;
    mesh.texCoord0Offset=4 * offset;
    offset+=TEX_COORD_0_SIZE;
  }
  if (hasTexCoord1) {
    mesh.hasTexCoord1=hasTexCoord1;
    mesh.texCoord1Offset=4 * offset;
    offset+=TEX_COORD_1_SIZE;
  }
  if (hasNormals) {
    mesh.hasNormal=hasNormals;
    mesh.normalOffset=4 * offset;
    offset+=NORMAL_SIZE;
  }
  if (hasColors) {
    mesh.hasColor=hasColors;
    mesh.colorOffset=4 * offset;
    offset+=COLOR_SIZE;
  }
  return mesh;
}
