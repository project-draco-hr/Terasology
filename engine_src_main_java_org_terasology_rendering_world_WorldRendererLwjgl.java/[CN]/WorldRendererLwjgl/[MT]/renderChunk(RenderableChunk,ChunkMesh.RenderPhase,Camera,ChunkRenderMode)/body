{
  if (chunk.hasMesh()) {
    final Vector3f cameraPosition=camera.getPosition();
    final Vector3f chunkPosition=chunk.getPosition().toVector3f();
    final Vector3f chunkPositionRelToCamera=new Vector3f(chunkPosition.x * ChunkConstants.SIZE_X - cameraPosition.x,chunkPosition.y * ChunkConstants.SIZE_Y - cameraPosition.y,chunkPosition.z * ChunkConstants.SIZE_Z - cameraPosition.z);
    if (mode == ChunkRenderMode.DEFAULT || mode == ChunkRenderMode.REFLECTION) {
      if (phase == ChunkMesh.RenderPhase.REFRACTIVE) {
        chunkShader.activateFeature(ShaderProgramFeature.FEATURE_REFRACTIVE_PASS);
      }
 else       if (phase == ChunkMesh.RenderPhase.ALPHA_REJECT) {
        chunkShader.activateFeature(ShaderProgramFeature.FEATURE_ALPHA_REJECT);
      }
      chunkShader.setFloat3("chunkPositionWorld",chunkPosition.x * ChunkConstants.SIZE_X,chunkPosition.y * ChunkConstants.SIZE_Y,chunkPosition.z * ChunkConstants.SIZE_Z);
      chunkShader.setFloat("animated",chunk.isAnimated() ? 1.0f : 0.0f);
      if (mode == ChunkRenderMode.REFLECTION) {
        chunkShader.setFloat("clip",camera.getClipHeight());
      }
 else {
        chunkShader.setFloat("clip",0.0f);
      }
      chunkShader.enable();
    }
 else     if (mode == ChunkRenderMode.SHADOW_MAP) {
      shadowMapShader.enable();
    }
 else     if (mode == ChunkRenderMode.Z_PRE_PASS) {
      CoreRegistry.get(ShaderManager.class).disableShader();
    }
    GL11.glPushMatrix();
    GL11.glTranslatef(chunkPositionRelToCamera.x,chunkPositionRelToCamera.y,chunkPositionRelToCamera.z);
    for (int i=0; i < verticalMeshSegments; i++) {
      if (!chunk.getMesh()[i].isEmpty()) {
        if (renderingDebugConfig.isRenderChunkBoundingBoxes()) {
          AABBRenderer aabbRenderer=new AABBRenderer(chunk.getSubMeshAABB(i));
          aabbRenderer.renderLocally(1f);
          statRenderedTriangles+=12;
        }
        chunk.getMesh()[i].render(phase);
        statRenderedTriangles+=chunk.getMesh()[i].triangleCount();
      }
    }
    if (mode == ChunkRenderMode.DEFAULT || mode == ChunkRenderMode.REFLECTION) {
      if (phase == ChunkMesh.RenderPhase.REFRACTIVE) {
        chunkShader.deactivateFeature(ShaderProgramFeature.FEATURE_REFRACTIVE_PASS);
      }
 else       if (phase == ChunkMesh.RenderPhase.ALPHA_REJECT) {
        chunkShader.deactivateFeature(ShaderProgramFeature.FEATURE_ALPHA_REJECT);
      }
    }
    GL11.glPopMatrix();
  }
 else {
    statChunkNotReady++;
  }
}
