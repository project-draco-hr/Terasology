{
  int[] depth=new int[ChunkConstants.SIZE_X * ChunkConstants.SIZE_Z];
  int[] startingRegen=new int[depth.length];
  Vector3i pos=new Vector3i();
  for (int z=0; z < ChunkConstants.SIZE_Z; ++z) {
    for (int x=0; x < ChunkConstants.SIZE_X; ++x) {
      int depthIndex=x + ChunkConstants.SIZE_X * z;
      startingRegen[depthIndex]=regenRules.getValue(fromChunk,new Vector3i(x,0,z));
      byte expectedValue=(byte)Math.min(startingRegen[depthIndex] + 1,ChunkConstants.MAX_SUNLIGHT_REGEN);
      Block prevBlock=fromChunk.getBlock(x,0,z);
      pos.set(x,ChunkConstants.SIZE_Y - 1,z);
      int currentValue=regenRules.getValue(toChunk,pos);
      while (expectedValue > currentValue && regenRules.canSpreadOutOf(prevBlock,Side.BOTTOM)) {
        prevBlock=toChunk.getBlock(pos);
        if (regenRules.canSpreadInto(prevBlock,Side.TOP)) {
          regenRules.setValue(toChunk,pos,expectedValue);
          depth[depthIndex]++;
          byte sunlight=(byte)(expectedValue - ChunkConstants.SUNLIGHT_REGEN_THRESHOLD);
          if (sunlight > 0 && sunlight > toChunk.getSunlight(pos)) {
            toChunk.setSunlight(pos,sunlight);
          }
          if (expectedValue < ChunkConstants.MAX_SUNLIGHT_REGEN) {
            expectedValue++;
          }
          pos.y--;
          currentValue=regenRules.getValue(toChunk,pos);
        }
 else {
          break;
        }
      }
    }
  }
  int[] adjDepths=new int[depth.length];
  TeraMath.populateMinAdjacent2D(depth,adjDepths,ChunkConstants.SIZE_X,ChunkConstants.SIZE_Z,!propagateExternal);
  if (propagateExternal) {
    for (int z=0; z < ChunkConstants.SIZE_Z; ++z) {
      adjDepths[z * ChunkConstants.SIZE_X]=0;
      adjDepths[ChunkConstants.SIZE_X - 1 + z * ChunkConstants.SIZE_X]=0;
    }
    for (int x=0; x < ChunkConstants.SIZE_X; ++x) {
      adjDepths[x]=0;
      adjDepths[x + ChunkConstants.SIZE_X * (ChunkConstants.SIZE_Z - 1)]=0;
    }
  }
  int[] adjStartingRegen=new int[depth.length];
  TeraMath.populateMinAdjacent2D(startingRegen,adjStartingRegen,ChunkConstants.SIZE_X,ChunkConstants.SIZE_Z,true);
  for (int z=0; z < ChunkConstants.SIZE_Z; ++z) {
    for (int x=0; x < ChunkConstants.SIZE_X; ++x) {
      int depthIndex=x + ChunkConstants.SIZE_X * z;
      int start=startingRegen[depthIndex];
      int adjStart=adjStartingRegen[depthIndex];
      if (start - adjStart > 1) {
        int initialDepth=Math.max(ChunkConstants.SUNLIGHT_REGEN_THRESHOLD - start,0);
        int finalDepth=depth[depthIndex];
        int strength=start + initialDepth - ChunkConstants.SUNLIGHT_REGEN_THRESHOLD + 1;
        for (int i=initialDepth; i < finalDepth; ++i) {
          sunlightPropagator.propagateFrom(toChunk.getBlockWorldPos(x,ChunkConstants.SIZE_Y - i - 1,z),(byte)(strength));
          if (strength < ChunkConstants.MAX_SUNLIGHT) {
            strength++;
          }
        }
      }
 else {
        int initialDepth=Math.max(adjDepths[depthIndex],ChunkConstants.SUNLIGHT_REGEN_THRESHOLD - start);
        byte strength=(byte)Math.min(ChunkConstants.MAX_SUNLIGHT,start + initialDepth - ChunkConstants.SUNLIGHT_REGEN_THRESHOLD + 1);
        for (int i=initialDepth; i < depth[depthIndex]; ++i) {
          sunlightPropagator.propagateFrom(toChunk.getBlockWorldPos(x,ChunkConstants.SIZE_Y - i - 1,z),strength);
          if (strength < ChunkConstants.MAX_SUNLIGHT) {
            strength++;
          }
          pos.y--;
        }
      }
    }
  }
}
