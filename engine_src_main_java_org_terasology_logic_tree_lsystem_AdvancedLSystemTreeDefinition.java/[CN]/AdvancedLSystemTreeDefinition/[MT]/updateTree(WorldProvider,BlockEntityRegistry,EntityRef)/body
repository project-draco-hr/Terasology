{
  LSystemTreeComponent lSystemTree=treeRef.getComponent(LSystemTreeComponent.class);
  if (lSystemTree != null) {
    long time=CoreRegistry.get(Time.class).getGameTimeInMs();
    if (shouldInitializeSapling(lSystemTree)) {
      logger.debug("Initializing sapling");
      FastRandom rand=new FastRandom(new Random().nextLong());
      lSystemTree.branchAngle=rand.randomFloat() * MAX_ANGLE_OFFSET;
      lSystemTree.rotationAngle=(float)Math.PI * rand.randomPosFloat();
      lSystemTree.generation=1;
      lSystemTree.initialized=true;
      lSystemTree.lastGrowthTime=time;
      treeRef.saveComponent(lSystemTree);
    }
 else     if (shouldProcessTreeGrowth(lSystemTree,time)) {
      Vector3i treeLocation=treeRef.getComponent(BlockComponent.class).getPosition();
      FastRandom rand=new FastRandom(new Random().nextLong());
      if (hasRoomToGrow(worldProvider,treeLocation)) {
        logger.debug("Growing tree");
        Map<Vector3i,Block> currentTree=generateTreeFromAxiom(lSystemTree.axion,lSystemTree.branchAngle,lSystemTree.rotationAngle);
        logger.debug("Starting axion generation");
        String nextAxion;
        if (lSystemTree.generated) {
          lSystemTree.generated=false;
          int generation=rand.randomIntAbs(maxGenerations);
          nextAxion=lSystemTree.axion;
          for (int i=0; i < generation; i++) {
            nextAxion=generateNextAxion(rand,nextAxion);
          }
          lSystemTree.generation=generation;
        }
 else {
          nextAxion=generateNextAxion(rand,lSystemTree.axion);
        }
        logger.debug("Finished axion generation");
        Map<Vector3i,Block> nextTree=generateTreeFromAxiom(nextAxion,lSystemTree.branchAngle,lSystemTree.rotationAngle);
        logger.debug("Starting replacement of blocks");
        updateTreeInGame(worldProvider,blockEntityRegistry,treeLocation,currentTree,nextTree);
        logger.debug("Finished replacement of blocks");
        lSystemTree.axion=nextAxion;
        lSystemTree.generation++;
        logger.debug("Generation: " + lSystemTree.generation + ", tree: "+ treeLocation);
        if (checkForDeath(lSystemTree.generation,rand.randomPosFloat())) {
          treeRef.removeComponent(LSystemTreeComponent.class);
        }
 else {
          lSystemTree.lastGrowthTime=time + rand.randomIntAbs(GROWTH_INTERVAL / 2);
          treeRef.saveComponent(lSystemTree);
        }
      }
    }
  }
}
