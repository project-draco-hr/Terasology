{
  boolean carryingTorch=CoreRegistry.get(LocalPlayer.class).isCarryingTorch();
  Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
  Quat4f worldRot=new Quat4f();
  Vector3f worldPos=new Vector3f();
  AxisAngle4f rot=new AxisAngle4f();
  Matrix4f matrix=new Matrix4f();
  Transform trans=new Transform();
  Transform normTrans=new Transform();
  glPushMatrix();
  glTranslated(-cameraPosition.x,-cameraPosition.y,-cameraPosition.z);
  for (  Material material : opaqueMesh.keys()) {
    OpenGLMesh lastMesh=null;
    OpenGLMaterial openglMat=(OpenGLMaterial)material;
    openglMat.enable();
    openglMat.setInt("carryingTorch",carryingTorch ? 1 : 0);
    openglMat.setFloat("light",1);
    openglMat.bindTextures();
    lastRendered=opaqueMesh.get(material).size();
    TFloatList vertexData=new TFloatArrayList();
    TIntList indexData=new TIntArrayList();
    int indexOffset=0;
    float[] openglMatrix=new float[16];
    FloatBuffer mBuffer=BufferUtils.createFloatBuffer(16);
    for (    EntityRef entity : opaqueMesh.get(material)) {
      if (!batch) {
        MeshComponent meshComp=entity.getComponent(MeshComponent.class);
        LocationComponent location=entity.getComponent(LocationComponent.class);
        if (location == null || meshComp.mesh == null) {
          continue;
        }
        if (meshComp.mesh.isDisposed()) {
          logger.error("Attempted to render disposed mesh");
          continue;
        }
        location.getWorldRotation(worldRot);
        location.getWorldPosition(worldPos);
        float worldScale=location.getWorldScale();
        matrix.set(worldRot,worldPos,worldScale);
        trans.set(matrix);
        AABB aabb=meshComp.mesh.getAABB().transform(trans);
        if (worldRenderer.isAABBVisible(aabb)) {
          if (meshComp.mesh != lastMesh) {
            if (lastMesh != null) {
              lastMesh.postRender();
            }
            lastMesh=(OpenGLMesh)meshComp.mesh;
            lastMesh.preRender();
          }
          glPushMatrix();
          trans.getOpenGLMatrix(openglMatrix);
          mBuffer.put(openglMatrix);
          mBuffer.flip();
          glMultMatrix(mBuffer);
          material.setFloat("light",worldRenderer.getRenderingLightValueAt(worldPos));
          lastMesh.doRender();
          glPopMatrix();
        }
      }
 else {
        MeshComponent meshComp=entity.getComponent(MeshComponent.class);
        LocationComponent location=entity.getComponent(LocationComponent.class);
        if (location == null)         continue;
        location.getWorldRotation(worldRot);
        location.getWorldPosition(worldPos);
        float worldScale=location.getWorldScale();
        matrix.set(worldRot,worldPos,worldScale);
        trans.set(matrix);
        matrix.set(worldRot,new Vector3f(),1);
        normTrans.set(matrix);
        AABB aabb=meshComp.mesh.getAABB().transform(trans);
        if (worldRenderer.isAABBVisible(aabb)) {
          indexOffset=((OpenGLMesh)meshComp.mesh).addToBatch(trans,normTrans,vertexData,indexData,indexOffset);
        }
        if (indexOffset > 100) {
          renderBatch(vertexData,indexData);
          vertexData.clear();
          indexData.clear();
        }
      }
    }
    if (lastMesh != null) {
      lastMesh.postRender();
    }
    if (batch) {
      renderBatch(vertexData,indexData);
    }
  }
  glPopMatrix();
}
