{
  int hmX=(((chunk.getChunkWorldPosX() / chunk.getChunkSizeX()) % 512) + 512) % 512;
  int hmZ=(((chunk.getChunkWorldPosZ() / chunk.getChunkSizeZ()) % 512) + 512) % 512;
  double scaleFactor=0.05 * chunk.getChunkSizeY();
  double p00=heightmap[hmX][hmZ] * scaleFactor;
  double p10=heightmap[(hmX - 1 + 512) % 512][(hmZ) % 512] * scaleFactor;
  double p11=heightmap[(hmX - 1 + 512) % 512][(hmZ + 1 + 512) % 512] * scaleFactor;
  double p01=heightmap[(hmX) % 512][(hmZ + 1 + 512) % 512] * scaleFactor;
  for (int x=0; x < chunk.getChunkSizeX(); x++) {
    for (int z=0; z < chunk.getChunkSizeZ(); z++) {
      WorldBiomeProvider.Biome type=biomeProvider.getBiomeAt(chunk.getBlockWorldPosX(x),chunk.getBlockWorldPosZ(z));
      double interpolatedHeight=lerp(x / (double)chunk.getChunkSizeX(),lerp(z / (double)chunk.getChunkSizeZ(),p10,p11),lerp(z / (double)chunk.getChunkSizeZ(),p00,p01));
      double threshold=Math.floor(interpolatedHeight);
      for (int y=chunk.getChunkSizeY() - 1; y >= 0; y--) {
        if (y == 0) {
          chunk.setBlock(x,y,z,mantle);
          break;
        }
 else         if (y < threshold) {
          chunk.setBlock(x,y,z,stone);
        }
 else         if (y == threshold) {
          if (y < chunk.getChunkSizeY() * 0.05 + 1) {
            chunk.setBlock(x,y,z,sand);
          }
 else           if (y < chunk.getChunkSizeY() * 0.05 * 12) {
            chunk.setBlock(x,y,z,grass);
          }
 else {
            chunk.setBlock(x,y,z,snow);
          }
        }
 else {
          if (y <= chunk.getChunkSizeY() / 20) {
            chunk.setBlock(x,y,z,water);
            chunk.setLiquid(x,y,z,new LiquidData(LiquidType.WATER,LiquidData.MAX_LIQUID_DEPTH));
          }
 else {
            chunk.setBlock(x,y,z,air);
          }
        }
      }
    }
  }
}
