{
  NetworkSystem networkSystem=CoreRegistry.get(NetworkSystem.class);
  DisplayDevice display=CoreRegistry.get(DisplayDevice.class);
  PerformanceMonitor.startActivity("Other");
  while (engineState == EngineState.RUNNING && !display.isCloseRequested()) {
    long totalDelta;
    float updateDelta;
    float subsystemsDelta;
    if (!display.isActive() && isHibernationAllowed()) {
      time.setPaused(true);
      Iterator<Float> updateCycles=time.tick();
      while (updateCycles.hasNext()) {
        updateCycles.next();
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        logger.warn("Display inactivity sleep interrupted",e);
      }
      display.processMessages();
      time.setPaused(false);
      continue;
    }
    processPendingState();
    if (currentState == null) {
      shutdown();
      break;
    }
    Iterator<Float> updateCycles=time.tick();
    PerformanceMonitor.startActivity("Network Update");
    networkSystem.update();
    PerformanceMonitor.endActivity();
    totalDelta=0;
    while (updateCycles.hasNext()) {
      updateDelta=updateCycles.next();
      totalDelta+=time.getDeltaInMs();
      PerformanceMonitor.startActivity("Main Update");
      currentState.update(updateDelta);
      PerformanceMonitor.endActivity();
    }
    subsystemsDelta=totalDelta / 1000f;
    for (    EngineSubsystem subsystem : getSubsystems()) {
      PerformanceMonitor.startActivity(subsystem.getClass().getSimpleName());
      subsystem.preUpdate(currentState,subsystemsDelta);
      PerformanceMonitor.endActivity();
    }
    GameThread.processWaitingProcesses();
    for (    EngineSubsystem subsystem : getSubsystems()) {
      PerformanceMonitor.startActivity(subsystem.getClass().getSimpleName());
      subsystem.postUpdate(currentState,subsystemsDelta);
      PerformanceMonitor.endActivity();
    }
    PerformanceMonitor.rollCycle();
    PerformanceMonitor.startActivity("Other");
  }
  PerformanceMonitor.endActivity();
  engineState=EngineState.INITIALIZED;
}
