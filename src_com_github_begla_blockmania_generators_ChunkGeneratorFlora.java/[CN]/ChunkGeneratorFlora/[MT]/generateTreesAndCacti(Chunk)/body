{
  for (int y=32; y < Configuration.CHUNK_DIMENSIONS.y; y++) {
    for (int x=0; x < Configuration.CHUNK_DIMENSIONS.x; x+=4) {
      for (int z=0; z < Configuration.CHUNK_DIMENSIONS.z; z+=4) {
        double rand=(_rand.randomDouble() + 1.0) / 2.0;
        double prob=1.0;
        BIOME_TYPE biome=calcBiomeTypeForGlobalPosition(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
        double humidity=calcHumidityAtGlobalPosition(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
        double temperature=calcTemperatureAtGlobalPosition(c.getBlockWorldPosX(x),c.getBlockWorldPosZ(z));
switch (biome) {
case PLAINS:
          prob=0.7;
        break;
case MOUNTAINS:
      prob=0.6;
    break;
case SNOW:
  prob=0.7;
break;
case FOREST:
prob=0.1;
break;
case DESERT:
prob=0.9;
break;
}
if (rand > prob) {
int randX=x + _rand.randomInt() % 12 + 6;
int randZ=z + _rand.randomInt() % 12 + 6;
if (temperature > 0.55 && humidity < 0.33 && (c.getBlock(randX,y,randZ) == 0x1 || c.getBlock(randX,y,randZ) == 0x17 || c.getBlock(randX,y,randZ) == 0x7)) c.getParent().getObjectGenerator("cactus").generate(c.getBlockWorldPosX(randX),y + 1,c.getBlockWorldPosZ(randZ),false);
 else if (c.getBlock(randX,y,randZ) == 0x1 || c.getBlock(randX,y,randZ) == 0x17) generateTree(c,randX,y,randZ);
}
}
}
}
}
