{
  if (chunk.hasMesh()) {
    final Vector3f cameraPosition=camera.getPosition();
    final Vector3f chunkPosition=chunk.getPosition().toVector3f();
    final Vector3f chunkPositionRelativeToCamera=new Vector3f(chunkPosition.x * ChunkConstants.SIZE_X - cameraPosition.x,chunkPosition.y * ChunkConstants.SIZE_Y - cameraPosition.y,chunkPosition.z * ChunkConstants.SIZE_Z - cameraPosition.z);
    if (mode == ChunkRenderMode.DEFAULT || mode == ChunkRenderMode.REFLECTION) {
      if (phase == ChunkMesh.RenderPhase.REFRACTIVE) {
        chunkShader.activateFeature(ShaderProgramFeature.FEATURE_REFRACTIVE_PASS);
      }
 else       if (phase == ChunkMesh.RenderPhase.ALPHA_REJECT) {
        chunkShader.activateFeature(ShaderProgramFeature.FEATURE_ALPHA_REJECT);
      }
      chunkShader.setFloat3("chunkPositionWorld",chunkPosition.x * ChunkConstants.SIZE_X,chunkPosition.y * ChunkConstants.SIZE_Y,chunkPosition.z * ChunkConstants.SIZE_Z);
      chunkShader.setFloat("animated",chunk.isAnimated() ? 1.0f : 0.0f);
      if (mode == ChunkRenderMode.REFLECTION) {
        chunkShader.setFloat("clip",camera.getClipHeight());
      }
 else {
        chunkShader.setFloat("clip",0.0f);
      }
      chunkShader.enable();
    }
 else     if (mode == ChunkRenderMode.SHADOW_MAP) {
      shadowMapShader.enable();
    }
 else     if (mode == ChunkRenderMode.Z_PRE_PASS) {
      context.get(ShaderManager.class).disableShader();
    }
    graphicState.preRenderSetupChunk(chunkPositionRelativeToCamera);
    if (chunk.hasMesh()) {
      if (renderingDebugConfig.isRenderChunkBoundingBoxes()) {
        AABBRenderer aabbRenderer=new AABBRenderer(chunk.getAABB());
        aabbRenderer.renderLocally(1f);
        statRenderedTriangles+=12;
      }
      chunk.getMesh().render(phase);
      statRenderedTriangles+=chunk.getMesh().triangleCount();
    }
    graphicState.postRenderCleanupChunk();
    if (mode == ChunkRenderMode.DEFAULT || mode == ChunkRenderMode.REFLECTION) {
      if (phase == ChunkMesh.RenderPhase.REFRACTIVE) {
        chunkShader.deactivateFeature(ShaderProgramFeature.FEATURE_REFRACTIVE_PASS);
      }
 else       if (phase == ChunkMesh.RenderPhase.ALPHA_REJECT) {
        chunkShader.deactivateFeature(ShaderProgramFeature.FEATURE_ALPHA_REJECT);
      }
    }
  }
 else {
    statChunkNotReady++;
  }
}
