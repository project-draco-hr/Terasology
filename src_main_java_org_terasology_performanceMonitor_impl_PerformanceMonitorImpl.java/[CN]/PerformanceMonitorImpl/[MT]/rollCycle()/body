{
  metricData.add(currentData);
  spikeData.forEachEntry(new TObjectDoubleProcedure<String>(){
    public boolean execute(    String s,    double v){
      spikeData.put(s,v * DECAY_RATE);
      return true;
    }
  }
);
  currentData.forEachEntry(new TObjectLongProcedure<String>(){
    public boolean execute(    String s,    long v){
      runningTotals.adjustOrPutValue(s,v,v);
      double time=v * timeFactor;
      double prev=spikeData.get(s);
      if (time > prev) {
        spikeData.put(s,time);
      }
      return true;
    }
  }
);
  while (metricData.size() > RETAINED_CYCLES) {
    metricData.get(0).forEachEntry(new TObjectLongProcedure<String>(){
      public boolean execute(      String s,      long v){
        runningTotals.adjustValue(s,-v);
        return true;
      }
    }
);
    metricData.remove(0);
  }
  currentData=new TObjectLongHashMap<String>();
  runningThreads.forEachEntry(new TObjectIntProcedure<String>(){
    public boolean execute(    String s,    int i){
      lastRunningThreads.adjustOrPutValue(s,i,i);
      return true;
    }
  }
);
  TObjectIntMap<String> temp=runningThreads;
  temp.clear();
  runningThreads=stoppedThreads;
  stoppedThreads=temp;
  lastRunningThreads.retainEntries(new TObjectIntProcedure<String>(){
    public boolean execute(    String s,    int i){
      return i > 0;
    }
  }
);
}
