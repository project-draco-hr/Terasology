{
  boolean carryingTorch=CoreRegistry.get(LocalPlayer.class).isCarryingTorch();
  Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
  Quat4f worldRot=new Quat4f();
  Vector3f worldPos=new Vector3f();
  AxisAngle4f rot=new AxisAngle4f();
  for (  Material material : opaqueMesh.keys()) {
    Mesh lastMesh=null;
    material.enable();
    material.setInt("carryingTorch",carryingTorch ? 1 : 0);
    material.setFloat("light",1);
    material.bindTextures();
    TFloatList vertexData=new TFloatArrayList();
    TIntList indexData=new TIntArrayList();
    int indexOffset=0;
    for (    EntityRef entity : opaqueMesh.get(material)) {
      if (!batch) {
        MeshComponent meshComp=entity.getComponent(MeshComponent.class);
        LocationComponent location=entity.getComponent(LocationComponent.class);
        if (location == null || meshComp.mesh == null)         continue;
        location.getWorldRotation(worldRot);
        location.getWorldPosition(worldPos);
        float worldScale=location.getWorldScale();
        AABB aabb=meshComp.mesh.getAABB().transform(worldRot,worldPos,worldScale);
        if (worldRenderer.isAABBVisible(aabb)) {
          if (meshComp.mesh != lastMesh) {
            if (lastMesh != null) {
              lastMesh.postRender();
            }
            lastMesh=meshComp.mesh;
            meshComp.mesh.preRender();
          }
          glPushMatrix();
          glTranslated(worldPos.x - cameraPosition.x,worldPos.y - cameraPosition.y,worldPos.z - cameraPosition.z);
          rot.set(worldRot);
          glRotatef(TeraMath.RAD_TO_DEG * rot.angle,rot.x,rot.y,rot.z);
          glScalef(worldScale,worldScale,worldScale);
          material.setFloat("light",worldRenderer.getRenderingLightValueAt(worldPos));
          meshComp.mesh.doRender();
          glPopMatrix();
        }
      }
 else {
        MeshComponent meshComp=entity.getComponent(MeshComponent.class);
        LocationComponent location=entity.getComponent(LocationComponent.class);
        if (location == null)         continue;
        location.getWorldRotation(worldRot);
        location.getWorldPosition(worldPos);
        float worldScale=location.getWorldScale();
        Transform transform=new Transform(new Matrix4f(worldRot,worldPos,worldScale));
        Transform normalTransform=new Transform(new Matrix4f(worldRot,new Vector3f(),1));
        AABB aabb=meshComp.mesh.getAABB().transform(transform);
        if (worldRenderer.isAABBVisible(aabb)) {
          indexOffset=meshComp.mesh.addToBatch(transform,normalTransform,vertexData,indexData,indexOffset);
        }
      }
    }
    if (lastMesh != null) {
      lastMesh.postRender();
    }
    if (batch) {
      PerformanceMonitor.startActivity("BatchRenderMesh");
      if (vertexData.size() == 0 || indexData.size() == 0)       continue;
      FloatBuffer vertexBuffer=BufferUtils.createFloatBuffer(vertexData.size());
      vertexBuffer.put(vertexData.toArray());
      vertexBuffer.flip();
      IntBuffer indexBuffer=BufferUtils.createIntBuffer(indexData.size());
      indexBuffer.put(indexData.toArray());
      indexBuffer.flip();
      GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER,batchVertexBuffer);
      GL15.glBufferData(GL15.GL_ARRAY_BUFFER,(FloatBuffer)null,GL15.GL_DYNAMIC_DRAW);
      GL15.glBufferSubData(GL15.GL_ARRAY_BUFFER,0,vertexBuffer);
      GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER,0);
      GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER,batchIndexBuffer);
      GL15.glBufferData(GL15.GL_ELEMENT_ARRAY_BUFFER,(IntBuffer)null,GL15.GL_DYNAMIC_DRAW);
      GL15.glBufferSubData(GL15.GL_ELEMENT_ARRAY_BUFFER,0,indexBuffer);
      GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER,0);
      glPushMatrix();
      glTranslated(-cameraPosition.x,-cameraPosition.y,-cameraPosition.z);
      glEnableClientState(GL_VERTEX_ARRAY);
      glEnableClientState(GL_TEXTURE_COORD_ARRAY);
      glEnableClientState(GL_COLOR_ARRAY);
      glEnableClientState(GL_NORMAL_ARRAY);
      GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER,batchVertexBuffer);
      GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER,batchIndexBuffer);
      glVertexPointer(Mesh.VERTEX_SIZE,GL11.GL_FLOAT,15 * 4,0);
      GL13.glClientActiveTexture(GL13.GL_TEXTURE0);
      glTexCoordPointer(Mesh.TEX_COORD_0_SIZE,GL11.GL_FLOAT,15 * 4,4 * 3);
      GL13.glClientActiveTexture(GL13.GL_TEXTURE1);
      glTexCoordPointer(Mesh.TEX_COORD_1_SIZE,GL11.GL_FLOAT,15 * 4,4 * 5);
      glColorPointer(Mesh.COLOR_SIZE,GL11.GL_FLOAT,15 * 4,4 * 11);
      glNormalPointer(GL11.GL_FLOAT,15 * 4,4 * 8);
      GL12.glDrawRangeElements(GL11.GL_TRIANGLES,0,indexData.size(),indexData.size(),GL_UNSIGNED_INT,0);
      glDisableClientState(GL_NORMAL_ARRAY);
      glDisableClientState(GL_COLOR_ARRAY);
      glDisableClientState(GL_TEXTURE_COORD_ARRAY);
      glDisableClientState(GL_VERTEX_ARRAY);
      GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER,0);
      GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER,0);
      glPopMatrix();
      PerformanceMonitor.endActivity();
    }
  }
}
