{
  Vector3f desiredVelocity=new Vector3f(movementComp.getDrive());
  float maxSpeed=movementComp.maxWaterSpeed;
  if (movementComp.isRunning) {
    maxSpeed*=movementComp.runFactor;
  }
  desiredVelocity.scale(maxSpeed);
  desiredVelocity.y-=UnderwaterGravity;
  Vector3f velocityDiff=new Vector3f(desiredVelocity);
  velocityDiff.sub(movementComp.getVelocity());
  velocityDiff.scale(Math.min(UnderwaterInertia * delta,1.0f));
  movementComp.getVelocity().x+=velocityDiff.x;
  movementComp.getVelocity().y+=velocityDiff.y;
  movementComp.getVelocity().z+=velocityDiff.z;
  float speed=movementComp.getVelocity().length();
  if (speed > movementComp.maxWaterSpeed) {
    movementComp.getVelocity().scale((speed - 4 * (speed - movementComp.maxWaterSpeed) * delta) / speed);
  }
  Vector3f worldPos=location.getWorldPosition();
  Vector3f oldPos=new Vector3f(worldPos);
  worldPos.y+=movementComp.getVelocity().y * delta;
  Vector3f extents=new Vector3f(movementComp.radius,0.5f * movementComp.height,movementComp.radius);
  extents.scale(location.getWorldScale());
  if (verticalHitTest(worldPos,oldPos,extents)) {
    movementComp.getVelocity().y=0;
  }
  oldPos.set(worldPos);
  worldPos.x+=movementComp.getVelocity().x * delta;
  worldPos.z+=movementComp.getVelocity().z * delta;
  if (horizontalHitTest(worldPos,oldPos,extents)) {
    entity.send(new HorizontalCollisionEvent());
    movementComp.getVelocity().x=(worldPos.x - oldPos.x) / delta;
    movementComp.getVelocity().z=(worldPos.z - oldPos.z) / delta;
  }
  location.setWorldPosition(worldPos);
  if (movementComp.faceMovementDirection && movementComp.getVelocity().lengthSquared() > 0.01f) {
    float yaw=(float)Math.atan2(movementComp.getVelocity().x,movementComp.getVelocity().z);
    AxisAngle4f axisAngle=new AxisAngle4f(0,1,0,yaw);
    location.getLocalRotation().set(axisAngle);
  }
}
